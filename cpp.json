{
    "CF模板": {
        "prefix": "CF模板",
        "body": [
            "// #pragma GCC optimize(\\\"Ofast,no-stack-protector\\\")",
            "#include <bits/stdc++.h>",
            "typedef long long ll;",
            "typedef double db;",
            "typedef pair<int, int> pii;",
            "typedef pair<ll, ll> pll;",
            "typedef pair<db, db> pdd;",
            "typedef pair<ll, int> pli;",
            "using namespace std;",
            "",
            "const int N = 2e5 + 10;",
            "const int inf = 1 << 30;",
            "const ll inf64 = 1ll << 60;",
            "const double PI = acos(-1);",
            "",
            "#define lowbit(x) (x & -x)",
            "",
            "int n, m, k, q;",
            "",
            "void work()",
            "{",
            "    cin >> n;",
            "}",
            "int main()",
            "{",
            "    cin.tie(nullptr)->sync_with_stdio(false);",
            "    int t;",
            "    cin >> t;",
            "    while (t-- > 0)",
            "    {",
            "        work();",
            "    }",
            "}"
        ],
        "description": "Snippet from ./CF模板.cpp"
    },
    "Dinic费用流": {
        "prefix": "Dinic费用流",
        "body": [
            "#include <bits/stdc++.h>",
            "namespace Dinic",
            "{",
            "    using T = int64_t;",
            "    const int NODE = 1e5 + 10;",
            "    const int EDGE = 1e5 + 10;",
            "    struct Edge",
            "    {",
            "        int to, nxt;",
            "        T flow, cost;",
            "        // flow剩余流量",
            "        // cost通过费用",
            "    } edge[EDGE];",
            "    int head[NODE];      // 邻接表头",
            "    int cnt = 1;         // 总边数",
            "    int pre[NODE];       // 表示当前增广路中每个节点的上一个节点",
            "    T flow[NODE];        // 到达当前节点的总流量",
            "    T cost[NODE];        // 到达当前节点的总花费",
            "    int last[NODE];      // 到达上一节点的边的编号",
            "    std::queue<int> que; // SPFA用队列",
            "    bool vis[NODE];      // 当前节点是否走过",
            "    int start, end;",
            "    void add(int x, int y, T flow, T cost)",
            "    {",
            "        edge[++cnt] = Edge{y, head[x], flow, cost};",
            "        head[x] = cnt;",
            "        edge[++cnt] = Edge{x, head[y], 0, -cost};",
            "        head[y] = cnt;",
            "    }",
            "    bool spfa()",
            "    {",
            "        memset(flow, 0x3f, sizeof flow);",
            "        memset(cost, 0x3f, sizeof cost);",
            "        memset(vis, 0, sizeof vis);",
            "        que.push(start);",
            "        pre[end] = -1;",
            "        cost[start] = 0;",
            "        vis[start] = 1;",
            "        while (!que.empty())",
            "        {",
            "            int x = que.front();",
            "            que.pop();",
            "            vis[x] = 0;",
            "            for (int i = head[x]; i; i = edge[i].nxt)",
            "            {",
            "                int y = edge[i].to;",
            "                if (edge[i].flow > 0 && cost[y] > cost[x] + edge[i].cost)",
            "                {",
            "                    flow[y] = std::min(flow[x], edge[i].flow);",
            "                    cost[y] = cost[x] + edge[i].cost;",
            "                    last[y] = i;",
            "                    pre[y] = x;",
            "                    if (!vis[y])",
            "                    {",
            "                        vis[y] = 1;",
            "                        que.push(y);",
            "                    }",
            "                }",
            "            }",
            "        }",
            "        return pre[end] != -1;",
            "    }",
            "    std::pair<T, T> work()",
            "    {",
            "        int maxflow = 0, mincost = 0;",
            "        while (spfa())",
            "        {",
            "            maxflow += flow[end];",
            "            mincost += cost[end] * flow[end];",
            "            int now = end;",
            "            while (now != start)",
            "            {",
            "                edge[last[now]].flow -= flow[end];",
            "                edge[last[now] ^ 1].flow += flow[end];",
            "                now = pre[now];",
            "            }",
            "        }",
            "        return {maxflow, mincost};",
            "    }",
            "}"
        ],
        "description": "Snippet from ./图论/网络流/Dinic费用流.cpp"
    },
    "Dinic最大流": {
        "prefix": "Dinic最大流",
        "body": [
            "#include <bits/stdc++.h>",
            "namespace Dinic",
            "{",
            "",
            "    using T = int32_t;",
            "    // 定义储存流量的类型，默认为int32_t",
            "    const int CNT_NODE = 2e5 + 10;",
            "    // 定义节点Node的数量",
            "    const int CNT_EDGE = 2e5 + 10;",
            "    // 定义边的数量",
            "    struct Edge",
            "    {",
            "        int to;",
            "        int nxt;",
            "        T flow;",
            "    } e[CNT_EDGE];",
            "    int head[CNT_NODE], cnt = 1;",
            "    int n;",
            "    void add(int x, int y, T flow)",
            "    {",
            "        e[++cnt] = Edge{y, head[x], flow};",
            "        head[x] = cnt;",
            "        e[++cnt] = Edge{x, head[y], 0};",
            "        head[y] = cnt;",
            "        n = std::max(n, x);",
            "        n = std::max(n, y);",
            "    }",
            "    int st, ed;",
            "    T dis[CNT_NODE];",
            "    int cur[CNT_NODE];",
            "    bool bfs()",
            "    {",
            "        std::queue<int> que;",
            "        que.push(ed);",
            "        memset(dis, 0, sizeof(dis));",
            "        dis[ed] = 1;",
            "        while (!que.empty())",
            "        {",
            "            auto x = que.front();",
            "            que.pop();",
            "            cur[x] = head[x];",
            "            for (auto i = head[x]; i; i = e[i].nxt)",
            "            {",
            "                auto y = e[i].to;",
            "                if (!dis[y] && e[i ^ 1].flow)",
            "                {",
            "                    dis[y] = dis[x] + 1;",
            "                    que.push(y);",
            "                }",
            "            }",
            "        }",
            "        return dis[st];",
            "    }",
            "    T dfs(int x, T flow)",
            "    {",
            "        auto rest = flow;",
            "        if (!flow || x == ed)",
            "            return flow;",
            "        for (auto &i = cur[x]; i && rest; i = e[i].nxt)",
            "        {",
            "            auto y = e[i].to;",
            "            if (dis[y] == dis[x] - 1 && e[i].flow)",
            "            {",
            "                auto k = dfs(y, std::min(rest, e[i].flow));",
            "                e[i].flow -= k;",
            "                e[i ^ 1].flow += k;",
            "                rest -= k;",
            "            }",
            "        }",
            "        return flow - rest;",
            "    }",
            "    T dinic()",
            "    {",
            "        for (int i = 1; i <= n; i++)",
            "            cur[i] = head[i];",
            "        T ans = 0, k;",
            "        while (bfs())",
            "            while (k = dfs(st, 0x3f3f3f3f))",
            "                ans += k;",
            "        return ans;",
            "    }",
            "}"
        ],
        "description": "Snippet from ./图论/网络流/Dinic最大流.cpp"
    },
    "Dijkstra": {
        "prefix": "Dijkstra",
        "body": [
            "#include <bits/stdc++.h>",
            "const int N = 2e5 + 10;",
            "",
            "namespace Graph",
            "{",
            "    typedef int64_t T;",
            "    typedef std::pair<int64_t, int32_t> pli;",
            "    std::vector<pli> to[N];",
            "    void add(int x, int y, T val)",
            "    {",
            "        to[x].push_back({val, y});",
            "    }",
            "    bool vis[N];",
            "    T dis[N];",
            "    void shortest_path(int32_t from)",
            "    {",
            "        // using Dijkstra",
            "        std::priority_queue<pli, std::vector<pli>, std::greater<pli>> q;",
            "        q.push(std::make_pair(0, from));",
            "        memset(dis, 0x3f, sizeof dis);",
            "        memset(vis, 0, sizeof vis);",
            "        dis[from] = 0;",
            "        while (!q.empty())",
            "        {",
            "            auto [nowval, x] = q.top();",
            "            q.pop();",
            "            if (vis[x])",
            "                continue;",
            "            vis[x] = 1;",
            "            for (auto [val, y] : to[x])",
            "                if (dis[y] > dis[x] + val)",
            "                {",
            "                    dis[y] = dis[x] + val;",
            "                    q.push(std::make_pair(dis[y], y));",
            "                }",
            "        }",
            "    }",
            "}"
        ],
        "description": "Snippet from ./图论/最短路/Dijkstra.cpp"
    },
    "普通Splay": {
        "prefix": "普通Splay",
        "body": [
            "template <class T>",
            "class SplayTree",
            "{",
            "private:",
            "#define LEFTSON 0",
            "#define RIGHTSON 1",
            "    struct Node",
            "    {",
            "        T val;",
            "        int son[2];",
            "        int fa;",
            "        int siz;",
            "        Node()",
            "        {",
            "            val = T();",
            "            son[LEFTSON] = son[RIGHTSON] = 0;",
            "            fa = siz = 0;",
            "        }",
            "        Node(T val, int cnt = 1)",
            "        {",
            "            this->val = val;",
            "            this->siz = 1;",
            "            this->son[0] = this->son[1] = 0;",
            "        }",
            "    };",
            "    vector<Node> tr;",
            "    int root;",
            "    /* 更新旋转后节点的信息 */",
            "    void update(int x)",
            "    {",
            "        tr[x].siz = tr[tr[x].son[LEFTSON]].siz + tr[tr[x].son[RIGHTSON]].siz + 1;",
            "    }",
            "    /*返回当前编号的节点是左节点还是右节点*/",
            "    int identify(int x)",
            "    {",
            "        if (tr[tr[x].fa].son[1] == x)",
            "            return RIGHTSON;",
            "        else",
            "            return LEFTSON;",
            "    }",
            "    /*根据情况进行左旋Zig或者右旋Zag*/",
            "    void rotate(int x)",
            "    {",
            "        int y = tr[x].fa, z = tr[y].fa;",
            "        int type = identify(x), typeY = 0;",
            "        if (z)",
            "            tr[z].son[identify(y)] = x;",
            "        tr[y].son[type] = tr[x].son[!type];",
            "        if (tr[x].son[!type])",
            "            tr[tr[x].son[!type]].fa = y;",
            "        tr[x].son[!type] = y;",
            "        tr[y].fa = x;",
            "        tr[x].fa = z;",
            "        update(y);",
            "        update(x);",
            "    }",
            "    /*伸展操作，将节点旋转至目标点*/",
            "    void splay(int x, int target = 0)",
            "    {",
            "        if (x == target)",
            "            return;",
            "        while (tr[x].fa != target)",
            "        {",
            "            int y = tr[x].fa;",
            "            if (tr[y].fa == 0) // 单Zig/Zag",
            "                rotate(x);",
            "            else",
            "            {",
            "                int typeX = identify(x), typeY = identify(y);",
            "                if (typeX == typeY) // 同向，ZigZig/ZagZag",
            "                {",
            "                    rotate(y);",
            "                    rotate(x);",
            "                }",
            "                else // 异向，ZigZag/ZagZig",
            "                {",
            "                    rotate(x);",
            "                    rotate(x);",
            "                }",
            "            }",
            "        }",
            "        if (target == 0)",
            "            root = x;",
            "    }",
            "",
            "public:",
            "    SplayTree()",
            "    {",
            "        tr.clear();",
            "        tr.push_back(Node());",
            "        root = 0;",
            "    }",
            "    void insert(T x)",
            "    {",
            "        if (root == 0)",
            "        {",
            "            tr.push_back(Node(x));",
            "            root = tr.size() - 1;",
            "        }",
            "        else",
            "        {",
            "            int p = root, pf = 0;",
            "            bool type = 0;",
            "            while (p)",
            "            {",
            "                pf = p;",
            "                type = x > tr[p].val;",
            "                p = tr[p].son[type];",
            "            }",
            "            tr.push_back(Node(x));",
            "            p = tr.size() - 1;",
            "            tr[pf].son[type] = p;",
            "            tr[p].fa = pf;",
            "            splay(p);",
            "        }",
            "    }",
            "    void remove(T val)",
            "    {",
            "        int p = root, pf = 0;",
            "        while (p && tr[p].val != val)",
            "        {",
            "            pf = p;",
            "            p = tr[p].son[val > tr[p].val];",
            "        }",
            "        if (!p)",
            "        {",
            "            if (pf)",
            "                splay(pf);",
            "            return;",
            "        }",
            "        splay(p);",
            "        int cur = tr[p].son[0];",
            "        if (cur == 0)",
            "        {",
            "            root = tr[p].son[1];",
            "            tr[root].fa = 0;",
            "            tr[p] = Node();",
            "            return;",
            "        }",
            "        root = cur;",
            "        while (tr[cur].son[1])",
            "            cur = tr[cur].son[1];",
            "        tr[cur].son[1] = tr[p].son[1];",
            "        tr[tr[p].son[1]].fa = cur;",
            "        tr[root].fa = 0;",
            "        tr[p] = Node();",
            "        splay(cur);",
            "    }",
            "    T find_by_rank(int rank)",
            "    {",
            "        int nowRank = 0, p = root;",
            "        while (true)",
            "        {",
            "            if (nowRank + tr[tr[p].son[0]].siz + 1 == rank)",
            "            {",
            "                splay(p);",
            "                return tr[p].val;",
            "            }",
            "            else if (nowRank + tr[tr[p].son[0]].siz >= rank)",
            "                p = tr[p].son[0];",
            "            else",
            "            {",
            "                nowRank += tr[tr[p].son[0]].siz + 1;",
            "                p = tr[p].son[1];",
            "            }",
            "        }",
            "    }",
            "    int order_by_rank(T val)",
            "    {",
            "        int rank = 0, p = root, pf = 0;",
            "        while (p != 0)",
            "        {",
            "            pf = p;",
            "            if (tr[p].val < val)",
            "            {",
            "                rank += tr[tr[p].son[0]].siz + 1;",
            "                p = tr[p].son[1];",
            "            }",
            "            else",
            "                p = tr[p].son[0];",
            "        }",
            "        splay(pf);",
            "        return rank + 1;",
            "    }",
            "    T prev(T val)",
            "    {",
            "        T ans = T();",
            "        int p = root, pf = 0;",
            "        while (p != 0)",
            "        {",
            "            pf = p;",
            "            if (tr[p].val >= val)",
            "                p = tr[p].son[0];",
            "            else",
            "            {",
            "                ans = tr[p].val;",
            "                p = tr[p].son[1];",
            "            }",
            "        }",
            "        splay(pf);",
            "        return ans;",
            "    }",
            "    T next(T val)",
            "    {",
            "        T ans = T();",
            "        int p = root, pf = 0;",
            "        while (p != 0)",
            "        {",
            "            pf = p;",
            "            if (tr[p].val <= val)",
            "                p = tr[p].son[1];",
            "            else",
            "            {",
            "                ans = tr[p].val;",
            "                p = tr[p].son[0];",
            "            }",
            "        }",
            "        splay(pf);",
            "        return ans;",
            "    }",
            "#undef LEFTSON",
            "#undef RIGHTSON",
            "};"
        ],
        "description": "Snippet from ./数据结构/普通Splay.cpp"
    },
    "树链剖分": {
        "prefix": "树链剖分",
        "body": [
            "template <class T>",
            "struct SegmentTree",
            "{",
            "    struct Node",
            "    {",
            "        T val, lazy;",
            "        int l, r;",
            "    };",
            "    vector<Node> tr;",
            "    void update(int p)",
            "    {",
            "        tr[p].val = (tr[p << 1].val + tr[p << 1 | 1].val);",
            "    }",
            "    void build(int l, int r, vector<T> &a, int p = 1)",
            "    {",
            "",
            "        tr[p].l = l;",
            "        tr[p].r = r;",
            "        tr[p].lazy = 0;",
            "        if (l == r)",
            "        {",
            "            tr[p].val = a[l];",
            "            return;",
            "        }",
            "        int mid = (l + r) >> 1;",
            "        build(l, mid, a, p << 1);",
            "        build(mid + 1, r, a, p << 1 | 1);",
            "        update(p);",
            "    }",
            "    SegmentTree() {}",
            "    SegmentTree(int n)",
            "    {",
            "        tr.resize(n * 4);",
            "        vector<T> empty(n);",
            "        build(0, n - 1, empty);",
            "    }",
            "    SegmentTree(vector<T> &a)",
            "    {",
            "        int n = a.size();",
            "        tr.resize(n * 4);",
            "        build(0, n - 1, a);",
            "    }",
            "    void pushdown(int p)",
            "    {",
            "        if (tr[p].lazy)",
            "        {",
            "            T t = tr[p].lazy;",
            "            tr[p << 1].val += t * (tr[p << 1].r - tr[p << 1].l + 1);",
            "            tr[p << 1].lazy += t;",
            "            tr[p << 1 | 1].val += t * (tr[p << 1 | 1].r - tr[p << 1 | 1].l + 1);",
            "            tr[p << 1 | 1].lazy += t;",
            "            tr[p].lazy = 0;",
            "        }",
            "    }",
            "    T query(int l, int r, int p = 1)",
            "    {",
            "        if (l <= tr[p].l && tr[p].r <= r)",
            "            return tr[p].val;",
            "        int mid = (tr[p].l + tr[p].r) >> 1;",
            "        T sum = 0;",
            "        pushdown(p);",
            "        if (l <= mid)",
            "            sum += query(l, r, p << 1);",
            "        if (mid < r)",
            "            sum += query(l, r, p << 1 | 1);",
            "        return sum;",
            "    }",
            "    void add(int l, int r, int val, int p = 1)",
            "    {",
            "        if (l <= tr[p].l && tr[p].r <= r)",
            "        {",
            "            tr[p].val += (tr[p].r - tr[p].l + 1) * val;",
            "            tr[p].lazy += val;",
            "            return;",
            "        }",
            "        pushdown(p);",
            "        int mid = (tr[p].l + tr[p].r) >> 1;",
            "        if (l <= mid)",
            "            add(l, r, val, p << 1);",
            "        if (mid < r)",
            "            add(l, r, val, p << 1 | 1);",
            "        update(p);",
            "    }",
            "};",
            "template <class T>",
            "struct ChainPartition",
            "{",
            "    vector<vector<int>> son;",
            "    vector<int> dep, top, siz, hson, lnk2seg, lnk2tree, f;",
            "    vector<T> segval, treeval;",
            "    int dfnCount;",
            "    SegmentTree<T> tr;",
            "    ChainPartition() {}",
            "    ChainPartition(int n)",
            "    {",
            "        dfnCount = 0;",
            "        segval.resize(n);",
            "        f.resize(n);",
            "        dep.resize(n);",
            "        top.resize(n);",
            "        siz.resize(n);",
            "        hson.resize(n);",
            "        lnk2seg.resize(n);",
            "        lnk2tree.resize(n);",
            "        son.resize(n);",
            "        tr = SegmentTree<T>(n);",
            "    }",
            "    ChainPartition(vector<T> a)",
            "    {",
            "        int n = a.size();",
            "        dfnCount = 0;",
            "        segval.resize(n);",
            "        f.resize(n);",
            "        dep.resize(n);",
            "        top.resize(n);",
            "        siz.resize(n);",
            "        hson.resize(n);",
            "        lnk2seg.resize(n);",
            "        lnk2tree.resize(n);",
            "        son.resize(n);",
            "        treeval = a;",
            "    }",
            "    void addEdge(int x, int y)",
            "    {",
            "        son[x].push_back(y);",
            "        son[y].push_back(x);",
            "    }",
            "    void dfs1(int x, int fa, int depth = 1)",
            "    {",
            "        dep[x] = depth;",
            "        siz[x] = 1;",
            "        hson[x] = -1;",
            "        f[x] = fa;",
            "        for (int y : son[x])",
            "        {",
            "            if (y == fa)",
            "                continue;",
            "            dfs1(y, x, depth + 1);",
            "            siz[x] += siz[y];",
            "            if (hson[x] == -1 || siz[hson[x]] < siz[y])",
            "                hson[x] = y;",
            "        }",
            "    }",
            "    void dfs2(int x, int nowtop)",
            "    {",
            "        top[x] = nowtop;",
            "        lnk2seg[x] = dfnCount++;",
            "        lnk2tree[lnk2seg[x]] = x;",
            "        segval[lnk2seg[x]] = treeval[x];",
            "        if (hson[x] == -1)",
            "            return;",
            "        dfs2(hson[x], nowtop);",
            "        for (int y : son[x])",
            "        {",
            "            if (y == f[x] || y == hson[x])",
            "                continue;",
            "            dfs2(y, y);",
            "        }",
            "    }",
            "    void init(int root = 0)",
            "    {",
            "        dfs1(root, -1);",
            "        dfs2(root, root);",
            "        tr = SegmentTree(segval);",
            "    }",
            "    T querySubtree(int x)",
            "    {",
            "        return tr.query(lnk2seg[x], lnk2seg[x] + siz[x] - 1);",
            "    }",
            "    void addSubtree(int x, T val)",
            "    {",
            "        tr.add(lnk2seg[x], lnk2seg[x] + siz[x] - 1, val);",
            "    }",
            "    int getLCA(int x, int y)",
            "    {",
            "        while (top[x] != top[y])",
            "        {",
            "            if (dep[top[x]] < dep[top[y]])",
            "                swap(x, y);",
            "            x = f[top[x]];",
            "        }",
            "        if (dep[x] < dep[y])",
            "            return x;",
            "        else",
            "            return y;",
            "    }",
            "    void add(int x, int y, T val)",
            "    {",
            "        while (top[x] != top[y])",
            "        {",
            "            if (dep[top[x]] < dep[top[y]])",
            "                swap(x, y);",
            "            tr.add(lnk2seg[top[x]], lnk2seg[x], val);",
            "            x = f[top[x]];",
            "        }",
            "        if (dep[x] > dep[y])",
            "            swap(x, y);",
            "        tr.add(lnk2seg[x], lnk2seg[y], val);",
            "    }",
            "    T query(int x, int y)",
            "    {",
            "        T ans = 0;",
            "        while (top[x] != top[y])",
            "        {",
            "            if (dep[top[x]] < dep[top[y]])",
            "                swap(x, y);",
            "            ans += tr.query(lnk2seg[top[x]], lnk2seg[x]);",
            "            x = f[top[x]];",
            "        }",
            "        if (dep[x] > dep[y])",
            "            swap(x, y);",
            "        ans += tr.query(lnk2seg[x], lnk2seg[y]);",
            "        return ans;",
            "    }",
            "};"
        ],
        "description": "Snippet from ./数据结构/树链剖分.cpp"
    },
    "二维数组（带越界检查）": {
        "prefix": "二维数组（带越界检查）",
        "body": [
            "/*",
            " * 类模板实现的二维矩阵",
            " * 实现功能：",
            " * 1. 当数组越界时返回缺省值而非直接报错",
            " * 2. 通过成员函数获取行列数",
            " */",
            "",
            "template <typename T>",
            "class Matrix",
            "{",
            "private:",
            "public:",
            "    Matrix(size_t rows, size_t cols, const T &initial_value = T())",
            "        : rows_(rows), cols_(cols), data_(rows, std::vector<T>(cols, initial_value)) {}",
            "",
            "    // 重载()运算符用于访问行列列",
            "    T &operator()(size_t row, size_t col)",
            "    {",
            "        if (row < 0 || row >= rows_ || col < 0 || col >= cols_)",
            "        {",
            "            // std::cerr << \\\"Error: Index out of bounds\\n\\\";",
            "            //  返回一个默认值，默认为0。",
            "            static T default_value = 0;",
            "            return default_value;",
            "        }",
            "        return data_[row][col];",
            "    }",
            "",
            "    // 用于获取行数和列数的函数",
            "    size_t rows() const",
            "    {",
            "        return rows_;",
            "    }",
            "",
            "    size_t cols() const",
            "    {",
            "        return cols_;",
            "    }",
            "",
            "private:",
            "    size_t rows_;",
            "    size_t cols_;",
            "    std::vector<std::vector<T>> data_;",
            "};"
        ],
        "description": "Snippet from ./数据结构/二维数组（带越界检查）.cpp"
    },
    "线段树": {
        "prefix": "线段树",
        "body": [
            "#include <cstdint>",
            "/*",
            " * 线段树模板",
            " * 默认为区间加法",
            " * 注意：默认下标从0开始，范围[0, n)",
            " */",
            "template <class T>",
            "struct SegmentTree",
            "{",
            "    struct Node",
            "    {",
            "        T val, lazy;",
            "        int l, r;",
            "    };",
            "    vector<Node> tr;",
            "    void updata(int p)",
            "    {",
            "        tr[p].val = tr[p << 1].val + tr[p << 1 | 1].val;",
            "    }",
            "    void build(int l, int r, vector<T> &a, int p = 1)",
            "    {",
            "        if (l == r)",
            "        {",
            "            tr[p].l = tr[p].r = l;",
            "            tr[p].val = a[l];",
            "            return;",
            "        }",
            "        int mid = (l + r) >> 1;",
            "        build(l, mid, a, p << 1);",
            "        build(mid + 1, r, a, p << 1 | 1);",
            "        tr[p].l = l, tr[p].r = r;",
            "        updata(p);",
            "    }",
            "    SegmentTree(int n)",
            "    {",
            "        tr.clear();",
            "        tr.resize(n * 4);",
            "        build(0, n - 1, vector<T>(n));",
            "    }",
            "    SegmentTree(vector<T> &a)",
            "    {",
            "        int n = a.size();",
            "        tr.clear();",
            "        tr.resize(n * 4);",
            "        build(0, n - 1, a);",
            "    }",
            "",
            "    void spread(int p)",
            "    {",
            "        if (tr[p].lazy)",
            "        {",
            "            T t = tr[p].lazy;",
            "            tr[p << 1].val += t * (tr[p << 1].r - tr[p << 1].l + 1), tr[p << 1].lazy += t;",
            "            tr[p << 1 | 1].val += t * (tr[p << 1 | 1].r - tr[p << 1 | 1].l + 1), tr[p << 1 | 1].lazy += t;",
            "            tr[p].lazy = 0;",
            "        }",
            "    }",
            "    T query(int l, int r, int p = 1)",
            "    {",
            "        if (l <= tr[p].l && tr[p].r <= r)",
            "            return tr[p].val;",
            "        int mid = (tr[p].l + tr[p].r) >> 1;",
            "        T sum = 0;",
            "        spread(p);",
            "        if (l <= mid)",
            "            sum += query(l, r, p << 1);",
            "        if (mid < r)",
            "            sum += query(l, r, p << 1 | 1);",
            "        return sum;",
            "    }",
            "    void add(int l, int r, int val, int p = 1)",
            "    {",
            "        if (l <= tr[p].l && tr[p].r <= r)",
            "        {",
            "            tr[p].val += (tr[p].r - tr[p].l + 1) * val;",
            "            tr[p].lazy += val;",
            "            return;",
            "        }",
            "        spread(p);",
            "        int mid = (tr[p].l + tr[p].r) >> 1;",
            "        if (l <= mid)",
            "            add(l, r, val, p << 1);",
            "        if (mid < r)",
            "            add(l, r, val, p << 1 | 1);",
            "        updata(p);",
            "    }",
            "};"
        ],
        "description": "Snippet from ./数据结构/线段树.cpp"
    },
    "ST表": {
        "prefix": "ST表",
        "body": [
            "#include <vector>",
            "#include <cstdint>",
            "#include <algorithm>",
            "/*",
            " * RMQ算法模板",
            " * 默认维护区间最大值",
            " */",
            "namespace RMQ",
            "{",
            "    typedef int32_t T;",
            "    // 维护值的类型，默认为int32_t",
            "    std::vector<std::vector<T>> _data;",
            "    // 预处理出log2以提速",
            "    std::vector<int32_t> lg2;",
            "    // 定义维护的信息，默认为max",
            "    T func(T x, T y)",
            "    {",
            "        return std::max(x, y);",
            "    }",
            "    void init(std::vector<T> a)",
            "    {",
            "        int n = a.size();",
            "        lg2 = std::vector<int>(n + 1);",
            "        lg2[1] = 0;",
            "        for (int i = 2; i <= n; i++)",
            "            lg2[i] = lg2[i >> 1] + 1;",
            "        _data = std::vector<std::vector<int>>(n, std::vector<int>(lg2[n] + 1));",
            "        for (int i = 0; i < n; i++)",
            "            _data[i][0] = a[i];",
            "        for (int bit = 1; bit <= lg2[n]; bit++)",
            "            for (int i = 0; i + (1 << bit) - 1 < n; i++)",
            "                _data[i][bit] = func(_data[i][bit - 1], _data[i + (1 << (bit - 1))][bit - 1]);",
            "    }",
            "    T query(size_t l, size_t r)",
            "    {",
            "        int32_t bit = lg2[r - l + 1];",
            "        return func(_data[l][bit], _data[r - (1 << bit) + 1][bit]);",
            "    }",
            "}"
        ],
        "description": "Snippet from ./数据结构/ST表.cpp"
    },
    "LCT": {
        "prefix": "LCT",
        "body": [
            "#include <algorithm>",
            "#include <iostream>",
            "#include <vector>",
            "/*",
            " * LCT模板",
            " * Info 表示值，Tag 表示标记",
            " */",
            "template <typename _Info, typename _Tag>",
            "class LCT",
            "{",
            "public:",
            "    LCT() : m_size(0) {}",
            "    LCT(const int &_n, const _Info &_v = _Info())",
            "    {",
            "        init(_n, _v);",
            "    }",
            "    LCT(const std::vector<_Info> &_init)",
            "    {",
            "        init(_init);",
            "    }",
            "    void init(const int &_n, const _Info &_v = _Info())",
            "    {",
            "        init(std::vector<_Info>(_n, _v));",
            "    }",
            "    void init(const std::vector<_Info> &_init)",
            "    {",
            "        resize(_init.size());",
            "        for (size_t i = 0; i < m_size; ++i)",
            "            val[i + 1] = _init[i];",
            "    }",
            "    void resize(const size_t &s)",
            "    {",
            "        m_size = s;",
            "        fa.resize(m_size + 1);",
            "        siz.resize(m_size + 1);",
            "        ch.resize(m_size + 1);",
            "        sta.resize(m_size + 1);",
            "        rev.resize(m_size + 1);",
            "        val.resize(m_size + 1);",
            "        sum.resize(m_size + 1);",
            "        tag.resize(m_size + 1);",
            "        for (size_t i = 0; i <= m_size; ++i)",
            "            ch[i].resize(2);",
            "    }",
            "    size_t size() const { return m_size; }",
            "    bool empty() const { return !m_size; }",
            "    int findroot(int x)",
            "    {",
            "        access(x);",
            "        _splay(x);",
            "        while (ch[x][0])",
            "        {",
            "            pushdown(x);",
            "            x = ch[x][0];",
            "        }",
            "        _splay(x);",
            "        return x;",
            "    }",
            "    void makeroot(const int &x)",
            "    {",
            "        access(x);",
            "        _splay(x);",
            "        flip(x);",
            "    }",
            "    void link(const int &x, const int &y)",
            "    {",
            "        makeroot(x);",
            "        if (findroot(y) != x)",
            "            fa[x] = y;",
            "    }",
            "    void cut(const int &x, const int &y)",
            "    {",
            "        _split(x, y);",
            "        if (findroot(y) == x && fa[y] == x && !ch[y][0])",
            "        {",
            "            fa[y] = ch[x][1] = 0;",
            "            pushup(x);",
            "        }",
            "    }",
            "    void set(const int &x, const _Info &v = _Info())",
            "    {",
            "        _splay(x);",
            "        val[x] = v;",
            "        pushup(x);",
            "    }",
            "    void change(const int &x, const int &y, const _Tag &v)",
            "    {",
            "        _split(x, y);",
            "        apply(y, v);",
            "    }",
            "    _Info asksum(const int &x, const int &y)",
            "    {",
            "        _split(x, y);",
            "        return sum[y];",
            "    }",
            "",
            "private:",
            "    std::vector<int> fa, siz;",
            "    std::vector<std::vector<int>> ch;",
            "    std::vector<int> sta, rev;",
            "    std::vector<_Info> val, sum;",
            "    std::vector<_Tag> tag;",
            "    size_t m_size;",
            "    bool relation(const int &x) const",
            "    {",
            "        return ch[fa[x]][0] == x || ch[fa[x]][1] == x;",
            "    }",
            "    void pushup(const int &x)",
            "    {",
            "        sum[x] = sum[ch[x][0]] + val[x] + sum[ch[x][1]];",
            "        siz[x] = siz[ch[x][0]] + siz[ch[x][1]] + 1;",
            "    }",
            "    void flip(const int &x)",
            "    {",
            "        std::swap(ch[x][0], ch[x][1]);",
            "        rev[x] ^= 1;",
            "    }",
            "    void apply(const int &x, const _Tag &t)",
            "    {",
            "        val[x].apply(t);",
            "        sum[x].apply(t);",
            "        tag[x].apply(t);",
            "    }",
            "    void pushdown(const int &x)",
            "    {",
            "        if (rev[x])",
            "        {",
            "            if (ch[x][0])",
            "                flip(ch[x][0]);",
            "            if (ch[x][1])",
            "                flip(ch[x][1]);",
            "            rev[x] = 0;",
            "        }",
            "        if (ch[x][0])",
            "            apply(ch[x][0], tag[x]);",
            "        if (ch[x][1])",
            "            apply(ch[x][1], tag[x]);",
            "        tag[x] = _Tag();",
            "    }",
            "    void _rotate(const int &x)",
            "    {",
            "        int y = fa[x], z = fa[y], k = (ch[y][1] == x), v = ch[x][!k];",
            "        if (relation(y))",
            "            ch[z][ch[z][1] == y] = x;",
            "        ch[x][!k] = y;",
            "        ch[y][k] = v;",
            "        if (v)",
            "            fa[v] = y;",
            "        fa[y] = x;",
            "        fa[x] = z;",
            "        pushup(y);",
            "        pushup(x);",
            "    }",
            "    void _splay(int x)",
            "    {",
            "        int y = x, top = 1;",
            "        sta[top] = x;",
            "        while (relation(y))",
            "            sta[++top] = y = fa[y];",
            "        while (top)",
            "            pushdown(sta[top--]);",
            "        while (relation(x))",
            "        {",
            "            y = fa[x];",
            "            top = fa[y];",
            "            if (relation(y))",
            "                _rotate((ch[y][1] == x) == (ch[top][1] == y) ? y : x);",
            "            _rotate(x);",
            "        }",
            "        pushup(x);",
            "    }",
            "    void access(int x)",
            "    {",
            "        for (int y = 0; x; y = x, x = fa[x])",
            "        {",
            "            _splay(x);",
            "            ch[x][1] = y;",
            "            pushup(x);",
            "        }",
            "    }",
            "    void _split(const int &x, const int &y)",
            "    {",
            "        makeroot(x);",
            "        access(y);",
            "        _splay(y);",
            "    }",
            "};",
            "typedef long long i64;",
            "const i64 mod = 998244353;",
            "struct Tag",
            "{",
            "    i64 add, mul;",
            "    Tag(i64 vadd = 0, i64 vmul = 1) : add(vadd), mul(vmul) {}",
            "    void apply(const Tag &v)",
            "    {",
            "        mul *= v.mul;",
            "        mul %= mod;",
            "        add *= v.mul;",
            "        add += v.add;",
            "        add %= mod;",
            "    }",
            "};",
            "struct Info",
            "{",
            "    i64 sum, siz;",
            "    Info(i64 v = 0, i64 z = 0) : sum(v % mod), siz(z) {}",
            "    void apply(const Tag &v)",
            "    {",
            "        sum = (sum * v.mul % mod + v.add * siz % mod) % mod;",
            "    }",
            "    Info operator+(const Info &b) const",
            "    {",
            "        return Info(sum + b.sum, siz + b.siz);",
            "    }",
            "};",
            "LCT<Info, Tag> tr;"
        ],
        "description": "Snippet from ./数据结构/LCT.cpp"
    },
    "李超线段树": {
        "prefix": "李超线段树",
        "body": [
            "/*",
            " * 李超线段树模板",
            " * 要求参数均为整数",
            " */",
            "typedef long long i64;",
            "template <int LEN>",
            "class Lichao_SegmentTree",
            "{",
            "public:",
            "    const i64 inf = 0x3f3f3f3f3f3f3f3f;",
            "    struct Line",
            "    {",
            "        i64 k, b;",
            "        Line(i64 _k = 0, i64 _b = 0) : k(_k), b(_b) {}",
            "        i64 at(i64 x) const { return k * x + b; }",
            "    };",
            "    static bool less(const Line &x, const Line &y, const i64 &p)",
            "    {",
            "        return x.at(p) < y.at(p);",
            "    }",
            "    static double intersect(const Line &x, const Line &y)",
            "    {",
            "        return double(y.b - x.b) / double(y.k - x.k);",
            "    }",
            "",
            "    void init(int x1, int x2)",
            "    {",
            "        if (x1 > x2)",
            "            minx = x2, maxx = x1;",
            "        else",
            "            minx = x1, maxx = x2;",
            "        build(1, minx, maxx);",
            "    }",
            "    void insert(const Line &g, int x1, int x2) { _insert(g, x1, x2, 1, minx, maxx); }",
            "    i64 ask(int x) const { return _getmax(x, 1, minx, maxx); }",
            "",
            "private:",
            "    struct Node",
            "    {",
            "        bool vis, has_line;",
            "        Line f;",
            "        Node() {}",
            "        Node(bool _v, bool _h) : vis(_v), has_line(_h), f() {}",
            "    };",
            "    Node tr[LEN << 2];",
            "    int minx, maxx;",
            "    void build(int p, int l, int r)",
            "    {",
            "        tr[p] = Node(false, false);",
            "        if (l == r)",
            "            return;",
            "        int mid = (l + r) >> 1;",
            "        build(p << 1, l, mid);",
            "        build(p << 1 | 1, mid + 1, r);",
            "    }",
            "    void _update(Line g, int p, int l, int r)",
            "    {",
            "        tr[p].vis = true;",
            "        if (!tr[p].has_line)",
            "        {",
            "            tr[p].has_line = true;",
            "            tr[p].f = g;",
            "            return;",
            "        }",
            "        Line &f = tr[p].f;",
            "        int mid = (l + r) >> 1;",
            "        if (less(f, g, mid))",
            "            std::swap(f, g);",
            "        if (l == r)",
            "            return;",
            "        if (less(f, g, l))",
            "            _update(g, p << 1, l, mid);",
            "        if (less(f, g, r))",
            "            _update(g, p << 1 | 1, mid + 1, r);",
            "    }",
            "    void _insert(const Line &g, int x, int y, int p, int l, int r)",
            "    {",
            "        tr[p].vis = true;",
            "        if (x <= l && r <= y)",
            "            return _update(g, p, l, r);",
            "        int mid = (l + r) >> 1;",
            "        if (x <= mid)",
            "            _insert(g, x, y, p << 1, l, mid);",
            "        if (y > mid)",
            "            _insert(g, x, y, p << 1 | 1, mid + 1, r);",
            "    }",
            "    i64 _getmax(int x, int p, int l, int r) const",
            "    {",
            "        if (!tr[p].vis)",
            "            return -inf;",
            "        i64 ans = tr[p].has_line ? tr[p].f.at(x) : -inf;",
            "        if (l == r)",
            "            return ans;",
            "        int mid = (l + r) >> 1;",
            "        if (x <= mid)",
            "            return std::max(ans, _getmax(x, p << 1, l, mid));",
            "        else",
            "            return std::max(ans, _getmax(x, p << 1 | 1, mid + 1, r));",
            "        return ans;",
            "    }",
            "};"
        ],
        "description": "Snippet from ./数据结构/李超线段树.cpp"
    },
    "FHQ Treap (Reverse)": {
        "prefix": "FHQ Treap (Reverse)",
        "body": [
            "#include <bits/stdc++.h>",
            "/*",
            " * FHQ Treap模板(区间反转版)",
            " * 功能：区间反转",
            " * 基准模板：洛谷P3391 【模板】文艺平衡树",
            " * Link: https://www.luogu.com.cn/problem/P3391",
            " */",
            "template <class T>",
            "class Tree",
            "{",
            "",
            "private:",
            "    struct Node",
            "    {",
            "        /* data */",
            "        size_t son[2];",
            "        int32_t rand;",
            "        size_t size;",
            "        T val;",
            "        bool tag;",
            "    };",
            "    int32_t seed;",
            "    size_t root, cnt;",
            "    std::vector<Node> tr;",
            "    int32_t rand()",
            "    {",
            "        return seed = ((int64_t)(seed) * 238973) % 2147483647;",
            "    }",
            "    int32_t add(T val)",
            "    {",
            "        tr.push_back(Node{{0, 0}, rand(), 1, val, 0});",
            "        return tr.size() - 1;",
            "    }",
            "    void spread(int32_t now)",
            "    {",
            "        if (!tr[now].tag)",
            "            return;",
            "        std::swap(tr[now].son[0], tr[now].son[1]);",
            "        tr[tr[now].son[0]].tag ^= 1;",
            "        tr[tr[now].son[1]].tag ^= 1;",
            "        tr[now].tag = 0;",
            "    }",
            "    void updata(size_t now)",
            "    {",
            "        tr[now].size = tr[tr[now].son[0]].size + tr[tr[now].son[1]].size + 1;",
            "    }",
            "    void split(size_t now, size_t &a, size_t &b, size_t val)",
            "    {",
            "        if (!now)",
            "        {",
            "            a = b = 0;",
            "            return;",
            "        }",
            "        spread(now);",
            "        if (tr[tr[now].son[0]].size + 1 <= val)",
            "        {",
            "            a = now;",
            "            split(tr[now].son[1], tr[now].son[1], b, val - tr[tr[now].son[0]].size - 1);",
            "        }",
            "        else",
            "        {",
            "            b = now;",
            "            split(tr[now].son[0], a, tr[now].son[0], val);",
            "        }",
            "        updata(now);",
            "    }",
            "    int32_t merge(size_t a, size_t b)",
            "    {",
            "        if (!a || !b)",
            "        {",
            "            return a | b;",
            "        }",
            "        if (tr[a].rand < tr[b].rand)",
            "        {",
            "            spread(a);",
            "            tr[a].son[1] = merge(tr[a].son[1], b);",
            "            updata(a);",
            "            return a;",
            "        }",
            "        else",
            "        {",
            "            spread(b);",
            "            tr[b].son[0] = merge(a, tr[b].son[0]);",
            "            updata(b);",
            "            return b;",
            "        }",
            "    }",
            "    void printF(size_t now)",
            "    {",
            "        spread(now);",
            "        if (tr[now].son[0])",
            "            printF(tr[now].son[0]);",
            "        std::cout << tr[now].val << ' ';",
            "        if (tr[now].son[1])",
            "            printF(tr[now].son[1]);",
            "    }",
            "",
            "public:",
            "    Tree(int32_t initSeed = 19260917)",
            "    {",
            "        tr.push_back(Node{{0, 0},",
            "                          rand(),",
            "                          0,",
            "                          std::numeric_limits<T>::min(),",
            "                          0});",
            "    };",
            "    void get(std::vector<T> a)",
            "    {",
            "        for (auto x : a)",
            "            root = merge(root, add(x));",
            "    }",
            "    void reverse(size_t l, size_t r)",
            "    {",
            "        size_t left, right, pos;",
            "        split(root, left, right, r);",
            "        split(left, left, pos, l - 1);",
            "        tr[pos].tag ^= 1;",
            "        root = merge(merge(left, pos), right);",
            "    }",
            "",
            "    void print()",
            "    {",
            "        printF(root);",
            "    }",
            "};",
            "Tree<int32_t> a;",
            "int32_t main()",
            "{",
            "    int32_t n, m;",
            "    std::cin >> n >> m;",
            "    std::vector<int32_t> num(n);",
            "    for (size_t i = 0; i < n; i++)",
            "        num[i] = i + 1;",
            "    a.get(num);",
            "    for (size_t i = 1, l, r; i <= m; i++)",
            "    {",
            "        std::cin >> l >> r;",
            "        a.reverse(l, r);",
            "    }",
            "    a.print();",
            "}"
        ],
        "description": "Snippet from ./数据结构/查找树/FHQ Treap (Reverse).cpp"
    },
    "01Treap(Trieset)": {
        "prefix": "01Treap(Trieset)",
        "body": [
            "",
            "#include <bits/stdc++.h>",
            "class Trieset",
            "{",
            "private:",
            "    std::vector<std::array<int, 2>> tr;",
            "    std::vector<int> siz;",
            "",
            "public:",
            "    Trieset()",
            "    {",
            "        tr.resize(2);",
            "        siz.resize(2);",
            "        tr[0] = {};",
            "        tr[1] = {};",
            "    }",
            "    void clear()",
            "    {",
            "        (*this) = Trieset();",
            "    }",
            "    void insert(int x, int cnt = 1)",
            "    {",
            "        int now = 1;",
            "        for (int i = 31, t; i >= 0; i--)",
            "        {",
            "            t = (x >> i) & 1;",
            "            if (!tr[now][t])",
            "            {",
            "                tr.push_back({});",
            "                siz.push_back(0);",
            "                tr[now][t] = tr.size() - 1;",
            "            }",
            "            siz[now = tr[now][t]] += cnt;",
            "        }",
            "    }",
            "    bool erase(int x, int cnt = 1)",
            "    {",
            "        int now = 1;",
            "        for (int i = 31, t; i >= 0; i--)",
            "        {",
            "            t = (x >> i) & 1;",
            "            if (!tr[now][t])",
            "                return 0;",
            "            siz[now = tr[now][t]] -= cnt;",
            "            if (siz[now] < 0)",
            "                siz[now] = 0;",
            "        }",
            "        return 1;",
            "    }",
            "    int find_by_rank(int rank)",
            "    {",
            "        int ans = 0, now = 1;",
            "        for (int i = 31; i >= 0; i--)",
            "        {",
            "            if (siz[tr[now][0]] < rank)",
            "            {",
            "                rank -= siz[tr[now][0]];",
            "                ans |= 1 << i;",
            "                now = tr[now][1];",
            "            }",
            "            else",
            "            {",
            "                now = tr[now][0];",
            "            }",
            "        }",
            "        return ans;",
            "    }",
            "    int find_rank(int val)",
            "    {",
            "        int rank = 0, now = 1;",
            "        for (int i = 31; i >= 0; i--)",
            "        {",
            "            int t = (val >> i) & 1;",
            "            rank += t * (siz[tr[now][0]]);",
            "            now = tr[now][t];",
            "        }",
            "        return rank + 1;",
            "    }",
            "    int prev(int val)",
            "    {",
            "        return find_by_rank(find_rank(val) - 1);",
            "    }",
            "    int next(int val)",
            "    {",
            "        return find_by_rank(find_rank(val + 1));",
            "    }",
            "} a;"
        ],
        "description": "Snippet from ./数据结构/查找树/01Treap(Trieset).cpp"
    },
    "exKMP": {
        "prefix": "exKMP",
        "body": [
            "// #pragma GCC optimize(2)",
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "",
            "const int N = 2e5 + 10;",
            "const int inf = 1 << 30;",
            "const long long llinf = 1ll << 60;",
            "const double PI = acos(-1);",
            "",
            "#define lowbit(x) (x & -x)",
            "typedef long long ll;",
            "typedef double db;",
            "typedef pair<int, int> pii;",
            "typedef pair<ll, ll> pll;",
            "typedef pair<db, db> pdd;",
            "typedef pair<ll, int> pli;",
            "",
            "long long n, m, k, q, x;",
            "",
            "/*",
            " * Z函数模板",
            " * 实现了基础的Z函数功能",
            " * 注意，根据定义，z[0]=0，而非z[0]=n",
            " * 通过例题: https://www.luogu.com.cn/problem/P10320?contestId=156706",
            " */",
            "",
            "namespace Zfunc",
            "{",
            "    vector<int> getZ(string s)",
            "    {",
            "        int n = s.length();",
            "        vector<int> z(n);",
            "        int l = 0, r = 0;",
            "        for (int i = 0; i < n; i++)",
            "        {",
            "            // 如果不超出范围，则直接继承",
            "            if (i <= r && i + z[i - l] - 1 < r)",
            "                z[i] = z[i - l];",
            "            // 否则，就尝试从r-l+1长度开始暴力扩展",
            "            else",
            "            {",
            "                z[i] = max(0, r - i + 1);",
            "                while (i + z[i] < n && s[i + z[i]] == s[z[i]])",
            "                    ++z[i];",
            "            }",
            "            // 更新l, r的边界",
            "            if (i + z[i] - 1 > r)",
            "                l = i, r = i + z[i] - 1;",
            "        }",
            "        return z;",
            "    }",
            "}",
            "void work()",
            "{",
            "    string a, b;",
            "    cin >> a >> b;",
            "    int n = a.length(), m = b.length();",
            "    string c = b + '*' + a;",
            "    auto z1 = Zfunc::getZ(b),",
            "         z2 = Zfunc::getZ(c);",
            "    z1[0] = m;",
            "    long long ans1 = 0, ans2 = 0;",
            "    for (int i = 0; i < m; i++)",
            "        ans1 ^= (ll)(i + 1) * (ll)(z1[i] + 1);",
            "    for (int i = m + 1; i < n + m + 1; i++)",
            "        ans2 ^= (ll)(i - m) * (ll)(z2[i] + 1);",
            "    cout << ans1 << endl",
            "         << ans2 << endl;",
            "}",
            "int main()",
            "{",
            "    ios::sync_with_stdio(0);",
            "    cin.tie(0);",
            "    cout.tie(0);",
            "    work();",
            "}"
        ],
        "description": "Snippet from ./字符串处理/exKMP.cpp"
    },
    "Trie": {
        "prefix": "Trie",
        "body": [
            "#include <algorithm>",
            "#include <cstdio>",
            "#include <map>",
            "#include <vector>",
            "#include <string>",
            "typedef long long i64;",
            "class Trie",
            "{",
            "public:",
            "    Trie() : m_size(1)",
            "    {",
            "        tree.clear();",
            "        tree.push_back(Node(-1, 0));",
            "    }",
            "    ~Trie() {}",
            "    int size() const { return m_size; }",
            "    int insert(char *s, int len)",
            "    {",
            "        int now = 0;",
            "        for (int i = 0; i < len; ++i)",
            "        {",
            "            if (!tree[now].nxt.count(s[i]))",
            "            {",
            "                tree[now].nxt[s[i]] = m_size++;",
            "                tree.push_back(Node(now, s[i]));",
            "            }",
            "            now = tree[now].nxt[s[i]];",
            "        }",
            "        return now;",
            "    }",
            "    friend class SAM;",
            "",
            "private:",
            "    struct Node",
            "    {",
            "        int fa;",
            "        char c;",
            "        std::map<char, int> nxt;",
            "        Node(int _1, char _2) : fa(_1), c(_2)",
            "        {",
            "            nxt.clear();",
            "        }",
            "    };",
            "    std::vector<Node> tree;",
            "    int m_size;",
            "};"
        ],
        "description": "Snippet from ./字符串处理/Trie.cpp"
    },
    "KMP": {
        "prefix": "KMP",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "const int N = 1e6;",
            "char a[N], b[N];",
            "int p[N];",
            "int main()",
            "{",
            "    int n, m;",
            "    cin >> (a + 1) >> (b + 1);",
            "    n = strlen(a + 1);",
            "    m = strlen(b + 1);",
            "    for (int i = 2, j = 0; i <= m; i++)",
            "    {",
            "        while (j && b[i] != b[j + 1])",
            "            j = p[j];",
            "        if (b[j + 1] == b[i])",
            "            j++;",
            "        p[i] = j;",
            "    }",
            "    for (int i = 1, j = 0; i <= n; i++)",
            "    {",
            "        while (j && a[i] != b[j + 1])",
            "            j = p[j];",
            "        if (a[i] == b[j + 1])",
            "            j++;",
            "        if (j == m)",
            "        {",
            "            cout << i - m + 1 << '\\n';",
            "            j = p[j];",
            "        }",
            "    }",
            "    for (int i = 1; i <= m; i++)",
            "        cout << p[i] << ' ';",
            "}"
        ],
        "description": "Snippet from ./字符串处理/KMP.cpp"
    },
    "字符串哈希": {
        "prefix": "字符串哈希",
        "body": [
            "// #pragma GCC optimize(2)",
            "#include <bits/stdc++.h>",
            "typedef std::pair<int, int> HashPair;",
            "class Hash",
            "{",
            "private:",
            "    const int CHAR_SIZE = 26; // 字符集大小",
            "    const int CC = (CHAR_SIZE + 1LL);",
            "    std::vector<HashPair> hashPow;",
            "    std::vector<HashPair> hashVal;",
            "    const int mod1 = 100000007,",
            "              mod2 = 100000037;",
            "    /*",
            "     *    字符转换函数",
            "     *    将字符转换为Hash中的编号",
            "     */",
            "    int transChar(char ch)",
            "    {",
            "        return (ch - 'A' + 1);",
            "    }",
            "    /*",
            "     *    序列生成Hash生成函数并储存",
            "     */",
            "    void makeHash(std::string &s)",
            "    {",
            "        size_t len = s.length();",
            "        hashPow.clear();",
            "        hashVal.clear();",
            "        hashPow.resize(len);",
            "        hashVal.resize(len);",
            "        hashPow[0] = {1LL, 1LL};",
            "        for (int i = 1; i < len; i++)",
            "        {",
            "            hashPow[i].first = (int64_t)hashPow[i - 1].first * CC % mod1;",
            "            hashPow[i].second = (int64_t)hashPow[i - 1].second * CC % mod2;",
            "        }",
            "        for (size_t i = 0; i < len; i++)",
            "        {",
            "            int p = transChar(s[i]);",
            "            if (i > 0)",
            "            {",
            "                hashVal[i].first = ((int64_t)hashVal[i - 1].first * CC + p) % mod1;",
            "                hashVal[i].second = ((int64_t)hashVal[i - 1].second * CC + p) % mod2;",
            "            }",
            "            else",
            "            {",
            "                hashVal[i].first = transChar(s[i]) % mod1;",
            "                hashVal[i].second = transChar(s[i]) % mod2;",
            "            }",
            "        }",
            "    }",
            "",
            "public:",
            "    Hash(std::string &str)",
            "    {",
            "        makeHash(str);",
            "    }",
            "    /*",
            "     *  截取某一段的Hash值",
            "     *    传入参数为[l, r]",
            "     *  默认返回一个HashPair",
            "     */",
            "    HashPair subHash(int l, int r)",
            "    {",
            "        if (l > r)",
            "            return {0, 0};",
            "        if (l == 0)",
            "            return hashVal[r];",
            "        else",
            "        {",
            "            HashPair result;",
            "            auto c1 = (int64_t)hashVal[l - 1].first * hashPow[r - l + 1].first % mod1;",
            "            result.first = ((int64_t)hashVal[r].first - c1 + mod1) % mod1;",
            "            auto c2 = (int64_t)hashVal[l - 1].second * hashPow[r - l + 1].second % mod2;",
            "            result.second = ((int64_t)hashVal[r].second - c2 + mod2) % mod2;",
            "            return result;",
            "        }",
            "    }",
            "};"
        ],
        "description": "Snippet from ./字符串处理/字符串哈希.cpp"
    },
    "Manacher": {
        "prefix": "Manacher",
        "body": [
            "int manacher(string s)",
            "{",
            "    string str;",
            "    str += \\\"*#\\\";",
            "    for (auto ch : s)",
            "    {",
            "        str.push_back(ch);",
            "        str.push_back('#');",
            "    }",
            "    str += \\\"#)\\\";",
            "    int n = str.length() - 1;",
            "    vector<int> p((int)str.length());",
            "    int maxid = 1, id = 1, ans = 0;",
            "    for (int i = 1; i < n; i++)",
            "    {",
            "        if (i < maxid)",
            "            p[i] = min(maxid - i, p[2 * id - i]);",
            "        else",
            "            p[i] = 1;",
            "        while (str[i - p[i]] == str[i + p[i]])",
            "            p[i]++;",
            "        if (maxid < i + p[i])",
            "        {",
            "            maxid = i + p[i];",
            "            id = i;",
            "        }",
            "        ans = max(ans, p[i] - 1);",
            "    }",
            "    return ans;",
            "}"
        ],
        "description": "Snippet from ./字符串处理/Manacher.cpp"
    },
    "PAM": {
        "prefix": "PAM",
        "body": [
            "class PAM",
            "{",
            "private:",
            "    struct Node",
            "    {",
            "        int fail;",
            "        int cnt;",
            "        int len;",
            "        int son[26];",
            "        Node()",
            "        {",
            "            fail = 0;",
            "            len = 0;",
            "            cnt = 0;",
            "            memset(son, 0, sizeof son);",
            "        }",
            "        Node(int len)",
            "        {",
            "            *this = Node();",
            "            this->len = len;",
            "        }",
            "    };",
            "    vector<Node> tr;",
            "    string str;",
            "    vector<int> id2Node;",
            "    int lst;",
            "    vector<vector<int>> fa;",
            "    int getfail(int x, int i)",
            "    {",
            "        while (i - tr[x].len - 1 < 0 || str[i - tr[x].len - 1] != str[i])",
            "            x = tr[x].fail;",
            "        return x;",
            "    }",
            "    int newnode(int len)",
            "    {",
            "        tr.push_back(Node(len));",
            "        return tr.size() - 1;",
            "    }",
            "",
            "public:",
            "    PAM()",
            "    {",
            "        lst = 0;",
            "        tr.clear();",
            "        newnode(0);",
            "        newnode(-1);",
            "        str.push_back('#');",
            "        tr[1].fail = 1;",
            "        tr[0].fail = 1;",
            "    }",
            "    void insert(char c)",
            "    {",
            "        str.push_back(c);",
            "        int i = str.length() - 1;",
            "        int x = getfail(lst, i);",
            "        if (!tr[x].son[c - 'a'])",
            "        {",
            "            int p = newnode(tr[x].len + 2);",
            "            int f = getfail(tr[x].fail, i);",
            "            tr[p].fail = tr[f].son[c - 'a'];",
            "            tr[x].son[c - 'a'] = p;",
            "            tr[p].cnt = tr[tr[p].fail].cnt + 1;",
            "        }",
            "        lst = tr[x].son[c - 'a'];",
            "        id2Node.push_back(lst);",
            "    }",
            "    void buildFailTree()",
            "    {",
            "        int n = tr.size();",
            "        fa = vector<vector<int>>(n, vector<int>(25));",
            "        for (int x = 0; x < n; x++)",
            "        {",
            "            fa[x][0] = tr[x].fail;",
            "            for (int i = 1; i < 25; i++)",
            "                fa[x][i] = fa[fa[x][i - 1]][i - 1];",
            "        }",
            "    }",
            "};"
        ],
        "description": "Snippet from ./字符串处理/自动机/PAM.cpp"
    },
    "AC自动机": {
        "prefix": "AC自动机",
        "body": [
            "// #pragma GCC optimize(2)",
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "",
            "const int N = 2e5 + 10;",
            "const int inf = 1 << 30;",
            "const long long llinf = 1ll << 60;",
            "const double PI = acos(-1);",
            "",
            "#define lowbit(x) (x & -x)",
            "typedef long long ll;",
            "typedef double db;",
            "typedef pair<int, int> pii;",
            "typedef pair<ll, ll> pll;",
            "typedef pair<db, db> pdd;",
            "typedef pair<ll, int> pli;",
            "",
            "/*",
            " * AC自动机模板",
            " * 本模板使用了建图优化以及拓扑排序",
            " * 最终第i个模式串匹配文本串次数为 vis[rev[i]]",
            " * 模板题https://www.luogu.com.cn/problem/P5357",
            " */",
            "namespace ACautomaton",
            "{",
            "    struct TrieNode",
            "    {",
            "        int son[26];",
            "        int fail;",
            "        int flag;",
            "        int ans;",
            "        TrieNode()",
            "        {",
            "            memset(son, 0, sizeof son);",
            "            fail = flag = ans = 0;",
            "        }",
            "        void clear(void)",
            "        {",
            "            (*this) = TrieNode();",
            "        }",
            "    };",
            "    TrieNode trie[N];",
            "    int vis[N];   // 记录能匹配到当前点的答案。",
            "    int rev[N];   // 索引，将第i个模式索引至答案的下标，作用是模式串去重",
            "    int indeg[N]; // getfail()所求的入度，用于拓扑排序",
            "                  // 注意，indeg[]的入度是fail边的入度",
            "    int cnt = 1;",
            "    /*",
            "     * 插入一个模式串str, 其编号为num",
            "     */",
            "    void insert(string &str, int num)",
            "    {",
            "        int u = 1;",
            "        for (auto ch : str)",
            "        {",
            "            int v = ch - 'a';",
            "            if (trie[u].son[v] == 0)",
            "                trie[u].son[v] = ++cnt;",
            "            u = trie[u].son[v];",
            "        }",
            "        if (!trie[u].flag)",
            "            trie[u].flag = num;",
            "        rev[num] = trie[u].flag;",
            "    }",
            "    /*",
            "     * 构建fail指针",
            "     * 为拓扑排序建立入度",
            "     */",
            "    void getfail(void)",
            "    {",
            "        std::queue<int> q;",
            "        for (int i = 0; i < 26; i++)",
            "            trie[0].son[i] = 1;",
            "        trie[1].fail = 0;",
            "        q.push(1);",
            "        while (!q.empty())",
            "        {",
            "            int u = q.front();",
            "            q.pop();",
            "            int fail = trie[u].fail;",
            "            for (int i = 0; i < 26; i++)",
            "            {",
            "                // 减去了跳fail边的操作",
            "                // 直接将儿子节点连到fail节点的对应儿子节点",
            "                // 相当于将fail边路径压缩",
            "                if (trie[u].son[i] == 0)",
            "                {",
            "                    trie[u].son[i] = trie[fail].son[i];",
            "                    continue;",
            "                }",
            "                int v = trie[u].son[i],",
            "                    nextFail = trie[fail].son[i];",
            "                indeg[nextFail]++;",
            "                trie[v].fail = nextFail;",
            "                q.push(v);",
            "            }",
            "        }",
            "    }",
            "    /*",
            "     * 导入待查寻的文本串",
            "     * 将匹配的路径记录到TrieNode::ans上",
            "     * 以便拓扑排序时求解",
            "     */",
            "    void query(string &str)",
            "    {",
            "        int u = 1;",
            "        for (auto ch : str)",
            "        {",
            "            u = trie[u].son[ch - 'a'];",
            "            trie[u].ans++;",
            "        }",
            "    }",
            "    /*",
            "     * 关键步骤拓扑排序",
            "     * 求解匹配答案",
            "     */",
            "    void topu(void)",
            "    {",
            "        std::queue<int> q;",
            "        for (int i = 1; i <= cnt; i++)",
            "            if (indeg[i] == 0)",
            "                q.push(i);",
            "        while (!q.empty())",
            "        {",
            "            int u = q.front();",
            "            q.pop();",
            "            if (trie[u].flag != 0)",
            "                vis[trie[u].flag] = trie[u].ans;",
            "            int fail = trie[u].fail;",
            "            trie[fail].ans += trie[u].ans;",
            "            --indeg[fail];",
            "            if (indeg[fail] == 0)",
            "                q.push(fail);",
            "        }",
            "    }",
            "    /*",
            "     *  返回第num个模式串对应的答案",
            "     */",
            "    int getAnswer(int num)",
            "    {",
            "        return vis[rev[num]];",
            "    }",
            "}",
            "",
            "int n, m, k, q;",
            "",
            "void work()",
            "{",
            "    cin >> n;",
            "    string s, t;",
            "    for (int i = 1; i <= n; i++)",
            "    {",
            "        cin >> s;",
            "        ACautomaton::insert(s, i);",
            "    }",
            "    cin >> t;",
            "    ACautomaton::getfail();",
            "    ACautomaton::query(t);",
            "    ACautomaton::topu();",
            "    for (int i = 1; i <= n; i++)",
            "        cout << ACautomaton::getAnswer(i) << '\\n';",
            "}",
            "int main()",
            "{",
            "    ios::sync_with_stdio(0);",
            "    cin.tie(0);",
            "    cout.tie(0);",
            "    work();",
            "}"
        ],
        "description": "Snippet from ./字符串处理/自动机/AC自动机.cpp"
    },
    "SAM": {
        "prefix": "SAM",
        "body": [
            "#include <algorithm>",
            "#include <cstdio>",
            "#include <map>",
            "#include <queue>",
            "#include <string>",
            "#include <vector>",
            "typedef long long i64;",
            "",
            "class Trie",
            "{",
            "public:",
            "    Trie() : m_size(1)",
            "    {",
            "        tree.clear();",
            "        tree.push_back(Node(-1, 0));",
            "    }",
            "    virtual ~Trie() {}",
            "    virtual int size() const { return m_size; }",
            "    int insert(char *s, int len)",
            "    {",
            "        int now = 0;",
            "        for (int i = 0; i < len; ++i)",
            "        {",
            "            if (!tree[now].nxt.count(s[i]))",
            "            {",
            "                tree[now].nxt[s[i]] = m_size++;",
            "                tree.push_back(Node(now, s[i]));",
            "            }",
            "            now = tree[now].nxt[s[i]];",
            "        }",
            "        return now;",
            "    }",
            "",
            "protected:",
            "    struct Node",
            "    {",
            "        int fa, lst;",
            "        char c;",
            "        std::map<char, int> nxt;",
            "        Node(int _1, char _2) : fa(_1), lst(0), c(_2)",
            "        {",
            "            nxt.clear();",
            "        }",
            "    };",
            "    std::vector<Node> tree;",
            "    int m_size;",
            "};",
            "",
            "class SAM : public Trie",
            "{",
            "public:",
            "    SAM() : m_size(1), _lst(0)",
            "    {",
            "        seq.clear();",
            "        seq.push_back(state(0, -1));",
            "    }",
            "    virtual ~SAM() {}",
            "    int size() const { return m_size; }",
            "    void build()",
            "    {",
            "        std::queue<int> q;",
            "        for (int t = 0; t < 26; ++t)",
            "            if (~Trie::tree[0].nxt[t])",
            "                q.push(Trie::tree[0].nxt[t]);",
            "        Trie::tree[0].lst = 0;",
            "        while (!q.empty())",
            "        {",
            "            int x = q.front();",
            "            q.pop();",
            "            Trie::tree[x].lst = saminsert(Trie::tree[x].c, Trie::tree[Trie::tree[x].fa].lst);",
            "            for (int t = 0; t < 26; ++t)",
            "                if (~Trie::tree[x].nxt[t])",
            "                    q.push(Trie::tree[x].nxt[t]);",
            "        }",
            "    }",
            "    friend i64 calc(SAM &sam);",
            "",
            "private:",
            "    struct state",
            "    {",
            "        int len, link, cnt;",
            "        std::map<char, int> nxt;",
            "        state(int _1, int _2, int _3 = 0) : len(_1), link(_2), cnt(_3)",
            "        {",
            "            nxt.clear();",
            "        }",
            "    };",
            "    std::vector<state> seq;",
            "    int m_size, _lst;",
            "    int saminsert(char c, int lst)",
            "    {",
            "        if (seq[lst].nxt.count(c))",
            "        {",
            "            int p = lst, q = seq[lst].nxt[c];",
            "            if (seq[q].len == seq[p].len + 1)",
            "                return q;",
            "            else",
            "            {",
            "                int r = m_size++;",
            "                seq.push_back(state(seq[p].len + 1, seq[q].link, 0));",
            "                seq[r].nxt = seq[q].nxt;",
            "                seq[q].link = r;",
            "                while (~p && seq[p].nxt.count(c) && seq[p].nxt[c] == q)",
            "                {",
            "                    seq[p].nxt[c] = r;",
            "                    p = seq[p].link;",
            "                }",
            "                return r;",
            "            }",
            "        }",
            "        int cur = m_size++;",
            "        seq.push_back(state(seq[lst].len + 1, -1, 1));",
            "        int p = lst;",
            "        lst = cur;",
            "        while (~p && !seq[p].nxt.count(c))",
            "        {",
            "            seq[p].nxt[c] = cur;",
            "            p = seq[p].link;",
            "        }",
            "        if (p == -1)",
            "        {",
            "            seq[cur].link = 0;",
            "        }",
            "        else",
            "        {",
            "            int q = seq[p].nxt[c];",
            "            if (seq[q].len == seq[p].len + 1)",
            "            {",
            "                seq[cur].link = q;",
            "            }",
            "            else",
            "            {",
            "                int r = m_size++;",
            "                seq.push_back(state(seq[p].len + 1, seq[q].link, 0));",
            "                seq[r].nxt = seq[q].nxt;",
            "                seq[cur].link = seq[q].link = r;",
            "                while (~p && seq[p].nxt.count(c) && seq[p].nxt[c] == q)",
            "                {",
            "                    seq[p].nxt[c] = r;",
            "                    p = seq[p].link;",
            "                }",
            "            }",
            "        }",
            "        return cur;",
            "    }",
            "};",
            "const int N = 1000010;",
            "char str[N];",
            "int buc[N << 1], pos[N << 1];",
            "SAM sam;",
            "i64 calc(SAM &sam)",
            "{",
            "    i64 ans = 0;",
            "    for (int i = 1; i < sam.size(); ++i)",
            "        buc[sam.seq[i].len]++;",
            "    for (int i = 1; i < sam.size(); ++i)",
            "        buc[i] += buc[i - 1];",
            "    for (int i = sam.size() - 1; i; --i)",
            "        pos[buc[sam.seq[i].len]--] = i;",
            "    for (int i = sam.size() - 1; i; --i)",
            "    {",
            "        int p = pos[i];",
            "        sam.seq[sam.seq[p].link].cnt += sam.seq[p].cnt;",
            "        if (sam.seq[p].cnt > 1)",
            "        {",
            "            //\tprintf(\\\"%d %d\\n\\\", sam.seq[p].cnt, sam.seq[p].len);",
            "            ans = std::max(ans, 1ll * sam.seq[p].cnt * sam.seq[p].len);",
            "        }",
            "    }",
            "    return ans;",
            "}",
            "// For the array version of nxt[], see P6139.cpp"
        ],
        "description": "Snippet from ./字符串处理/自动机/SAM.cpp"
    },
    "矩阵": {
        "prefix": "矩阵",
        "body": [
            "",
            "#include <bits/stdc++.h>",
            "",
            "/*",
            " * 矩阵类",
            " * 实现了矩阵加法、减法、乘法以及取模",
            " * 当MOD=0时相当于不取模",
            " */",
            "template <class T, T MOD = 0>",
            "class Matrix",
            "{",
            "private:",
            "    int32_t R, C;",
            "    std::vector<std::vector<T>> a;",
            "",
            "public:",
            "    Matrix() {}",
            "    /*",
            "     * 需要在初始化时传入其行数Rt与列数Ct",
            "     * 可选参数为矩阵初始初始值init_val",
            "     */",
            "    Matrix(const int Rt, const int Ct, T init_val = 0)",
            "    {",
            "        a = std::vector<std::vector<T>>(Rt, std::vector<T>(Ct, init_val));",
            "        R = Rt;",
            "        C = Ct;",
            "    }",
            "    Matrix(std::vector<std::vector<T>> b)",
            "    {",
            "        a = b;",
            "        R = a.size();",
            "        C = a[0].size();",
            "    }",
            "    Matrix<T, MOD> operator*(const Matrix<T, MOD> b)",
            "    {",
            "        try",
            "        {",
            "            if (C != b.R)",
            "                throw \\\"SIZE DIFF\\\";",
            "        }",
            "        catch (std::string code)",
            "        {",
            "            std::cerr << \\\"MATRIX ERROR @ OPERATOR * : \\\" + code << std::endl;",
            "            exit(0);",
            "        }",
            "        Matrix<T, MOD> c(R, b.C, 0);",
            "        for (int i = 0; i < R; i++)",
            "            for (int j = 0; j < b.C; j++)",
            "                for (int k = 0; k < C; k++)",
            "                {",
            "                    if (MOD != 0)",
            "                        c.a[i][j] = (c.a[i][j] + (a[i][k] * b.a[k][j]) % MOD) % MOD;",
            "                    else",
            "                        c.a[i][j] = (c.a[i][j] + a[i][k] * b.a[k][j]);",
            "                }",
            "        return c;",
            "    }",
            "    Matrix<T, MOD> operator+(const Matrix<T, MOD> b)",
            "    {",
            "        try",
            "        {",
            "            if (R != b.R || C != b.C)",
            "                throw \\\"SIZE DIFF\\\";",
            "        }",
            "        catch (std::string code)",
            "        {",
            "            std::cerr << \\\"MATRIX ERROR @ OPERATOR + : \\\" + code << std::endl;",
            "            exit(0);",
            "        }",
            "        Matrix<T, MOD> c(R, C, 0);",
            "        for (int i = 0; i < R; i++)",
            "            for (int j = 0; j < C; j++)",
            "                if (MOD != 0)",
            "                    c.a[i][j] = (a[i][j] + b.a[i][j]) % MOD;",
            "                else",
            "                    c.a[i][j] = (a[i][j] + b.a[i][j]);",
            "",
            "        return c;",
            "    }",
            "    Matrix<T, MOD> operator*(const T val)",
            "    {",
            "        Matrix<T, MOD> c(a);",
            "        for (int i = 0; i < R; i++)",
            "            for (int j = 0; j < C; j++)",
            "                if (MOD != 0)",
            "                    c.a[i][j] = (c.a[i][j] * val) % MOD;",
            "                else",
            "                    c.a[i][j] = (c.a[i][j] * val);",
            "        return c;",
            "    }",
            "    Matrix<T, MOD> operator%(const T val)",
            "    {",
            "        Matrix<T, MOD> c(a);",
            "        for (int i = 0; i < R; i++)",
            "            for (int j = 0; j < C; j++)",
            "                c.a[i][j] %= val;",
            "        return c;",
            "    }",
            "    T sum()",
            "    {",
            "        T ans = 0;",
            "        for (auto line : a)",
            "            for (auto x : line)",
            "                ans = (ans + x) % MOD;",
            "        return ans;",
            "    }",
            "    void print()",
            "    {",
            "        for (int i = 0; i < R; i++)",
            "            for (int j = 0; j < C; j++)",
            "                std::cout << a[i][j] << \\\" \\n\\\"[j == C - 1];",
            "    }",
            "};",
            "// 模板结束",
            "",
            "using namespace std;",
            "const int N = 2e5 + 10;",
            "const int inf = 1 << 30;",
            "const long long llinf = 1ll << 60;",
            "const double PI = acos(-1);",
            "",
            "#define lowbit(x) (x & -x)",
            "typedef long long ll;",
            "typedef double db;",
            "typedef pair<int, int> pii;",
            "typedef pair<ll, ll> pll;",
            "typedef pair<db, db> pdd;",
            "typedef pair<ll, int> pli;",
            "",
            "const ll mod = 1e9 + 7;",
            "template <typename T>",
            "T quickPow(T base, ll times, T initVal = 1)",
            "{",
            "    T ans = initVal;",
            "    while (times)",
            "    {",
            "        if (times & 1)",
            "            ans = ans * base % mod;",
            "        base = base * base % mod;",
            "        times >>= 1;",
            "    }",
            "    return ans;",
            "}",
            "void work()",
            "{",
            "    ll n, k;",
            "    cin >> n >> k;",
            "    vector<vector<ll>> a(n, vector<ll>(n));",
            "    for (int i = 0; i < n; i++)",
            "        for (int j = 0; j < n; j++)",
            "            cin >> a[i][j];",
            "    Matrix<ll, mod> bs(a);",
            "    if (k == 0)",
            "    {",
            "        for (int i = 1; i <= n; i++)",
            "            for (int j = 1; j <= n; j++)",
            "                cout << (int)(i == j) << \\\" \\n\\\"[j == n];",
            "    }",
            "    else",
            "        quickPow(bs, k - 1, bs).print();",
            "}",
            "int main()",
            "{",
            "    ios::sync_with_stdio(0);",
            "    cin.tie(0);",
            "    cout.tie(0);",
            "    work();",
            "}"
        ],
        "description": "Snippet from ./数学/矩阵.cpp"
    },
    "FFT": {
        "prefix": "FFT",
        "body": [
            "#include <algorithm>",
            "#include <iostream>",
            "#include <vector>",
            "#include <cmath>",
            "",
            "const double PI = std::acos(-1);",
            "",
            "class Complex",
            "{",
            "public:",
            "    Complex(double _real = 0, double _virtual = 0);",
            "    double getReal() const;",
            "    double getVirtual() const;",
            "    Complex operator+(const Complex &b) const;",
            "    Complex operator-(const Complex &b) const;",
            "    Complex operator*(const Complex &b) const;",
            "",
            "private:",
            "    double x, y;",
            "};",
            "Complex::Complex(double _real, double _virtual) : x(_real), y(_virtual) {}",
            "double Complex::getReal() const { return this->x; }",
            "double Complex::getVirtual() const { return this->y; }",
            "Complex Complex::operator+(const Complex &b) const",
            "{",
            "    return Complex(this->x + b.x, this->y + b.y);",
            "}",
            "Complex Complex::operator-(const Complex &b) const",
            "{",
            "    return Complex(this->x - b.x, this->y - b.y);",
            "}",
            "Complex Complex::operator*(const Complex &b) const",
            "{",
            "    return Complex(this->x * b.x - this->y * b.y, this->x * b.y + this->y * b.x);",
            "}",
            "",
            "/* recursive FFT",
            "void FFT(std::vector<Complex>& A, int flag = 1){",
            "    int n = A.size();",
            "    if(n == 1) return;",
            "    std::vector<Complex> A1(n >> 1), A2(n >> 1);",
            "    for(int i = 0; i < (n >> 1); ++i)",
            "        A1[i] = A[i << 1],",
            "        A2[i] = A[i << 1 | 1];",
            "    FFT(A1, flag); FFT(A2, flag);",
            "    Complex w1(std::cos(2.0 * PI / n), std::sin(2.0 * PI / n) * flag), wk(1, 0);",
            "    for(int k = 0; k < (n >> 1); wk = wk * w1, ++k)",
            "        A[k] = A1[k] + A2[k] * wk,",
            "        A[k + (n >> 1)] = A1[k] - A2[k] * wk;",
            "}",
            "*/",
            "",
            "// make reversed binary representation array",
            "std::vector<int> makerev(const int &len)",
            "{",
            "    std::vector<int> ans;",
            "    ans.emplace_back(0);",
            "    ans.emplace_back(len >> 1);",
            "    int l = 0;",
            "    while ((1 << l) < len)",
            "        l++;",
            "    for (int i = 2; i < len; ++i)",
            "        ans.emplace_back(ans[i >> 1] >> 1 | (i & 1) << (l - 1));",
            "    /*",
            "        ans[i >> 1] is the reversed representation of i >> 1",
            "        (i >> 1) << 1 = i, so in reversed representation we need ans[i >> 1] >> 1",
            "        if i & 1 == 1, then the MSB of reversed representation should be 1",
            "        that is (i & 1) << (l - 1)",
            "    */",
            "    return ans;",
            "}",
            "",
            "// iterative FFT",
            "void FFT(std::vector<Complex> &A, const int &flag = 1)",
            "{",
            "    static std::vector<int> rev;",
            "    int n = A.size();",
            "    if (int(rev.size()) != n)",
            "        rev.clear(),",
            "            rev = makerev(n);",
            "    for (int i = 0; i < n; ++i)",
            "        if (rev[i] > i)",
            "            std::swap(A[i], A[rev[i]]);",
            "    for (int len = 2, m = 1; len <= n; m = len, len <<= 1)",
            "    {",
            "        Complex w1(std::cos(2.0 * PI / len), std::sin(2.0 * PI / len) * flag), wk;",
            "        for (int l = 0, r = len; r <= n; l += len, r += len)",
            "        {",
            "            wk = Complex(1, 0);",
            "            for (int k = l; k < l + m; wk = wk * w1, ++k)",
            "            {",
            "                Complex x = A[k] + A[k + m] * wk,",
            "                        y = A[k] - A[k + m] * wk;",
            "                A[k] = x;",
            "                A[k + m] = y;",
            "            }",
            "        }",
            "    }",
            "}",
            "",
            "signed main(int argc, char **argv)",
            "{",
            "    std::cin.tie(nullptr)->sync_with_stdio(false);",
            "    int n, m, len = 1;",
            "    std::cin >> n >> m;",
            "    while (len <= (n + m))",
            "        len <<= 1; // to make the length a power of 2",
            "    std::vector<Complex> A(len), B(len);",
            "    for (int i = 0, x; i <= n; ++i)",
            "    {",
            "        std::cin >> x;",
            "        A[i] = Complex(x, 0);",
            "    }",
            "    for (int i = 0, x; i <= m; ++i)",
            "    {",
            "        std::cin >> x;",
            "        B[i] = Complex(x, 0);",
            "    }",
            "    FFT(A);",
            "    FFT(B);",
            "    for (int i = 0; i < len; ++i)",
            "        A[i] = A[i] * B[i];",
            "    FFT(A, -1);",
            "    for (int i = 0; i <= (n + m); ++i)",
            "        std::cout << int(A[i].getReal() / len + 0.5) << ' ';",
            "    std::cout << std::endl;",
            "    return 0;",
            "}"
        ],
        "description": "Snippet from ./数学/FFT.cpp"
    },
    "计算几何": {
        "prefix": "计算几何",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "typedef double design_float;",
            "const design_float PI = acos(-1);",
            "const design_float eps = 1e-7;",
            "struct Vector",
            "{",
            "    design_float x, y;",
            "    Vector(design_float x = 0, design_float y = 0)",
            "        : x(x), y(y)",
            "    {",
            "    }",
            "    Vector operator+(const Vector &b) const { return Vector(x + b.x, y + b.y); }",
            "    Vector operator-(const Vector &b) const { return Vector(x - b.x, y - b.y); }",
            "    Vector operator*(const design_float &b) const { return Vector(x * b, y * b); }",
            "    Vector operator/(const design_float &b) const { return Vector(x / b, y / b); }",
            "    design_float operator*(const Vector &b) const { return x * b.x + y * b.y; }",
            "    // 重定义^为叉乘",
            "    design_float operator^(const Vector &b) const { return x * b.y - y * b.x; }",
            "    design_float length() const { return sqrt(x * x + y * y); }",
            "    design_float angle() const { return atan2(y, x); }",
            "    Vector unit() const { return *this / length(); }",
            "    // 将向量旋转angle角度，angle为弧度制",
            "    Vector rotate(design_float angle) const",
            "    {",
            "        return Vector(x * cos(angle) - y * sin(angle), x * sin(angle) + y * cos(angle));",
            "    }",
            "};",
            "typedef Vector Point;",
            "struct Line",
            "{",
            "    Point a, b;",
            "    Vector vec() { return b - a; }",
            "    Line(Point a = Point(), Point b = Point())",
            "        : a(a), b(b)",
            "    {",
            "    }",
            "    // 判断点c在直线上",
            "    bool isPointOnLine(Point c) { return ((b - a) ^ (c - a)) == 0; }",
            "    // 判断点c在线段上",
            "    bool isPointOnSegment(Point c)",
            "    {",
            "        return ((b - a) ^ (c - a)) == 0 && (c - a) * (c - b) <= 0;",
            "    }",
            "    // 求点c到直线的距离",
            "    design_float distanceToLine(Point c)",
            "    {",
            "        return fabs(((b - a) ^ (c - a)) / (b - a).length());",
            "    }",
            "    // 求点c到线段的距离",
            "    design_float distanceToSegment(Point c)",
            "    {",
            "        if ((c - a) * (b - a) < 0)",
            "            return (c - a).length();",
            "        if ((c - b) * (a - b) < 0)",
            "            return (c - b).length();",
            "        return distanceToLine(c);",
            "    }",
            "    // 求点c到线段的最近点",
            "    Point nearestPointToSegment(Point c)",
            "    {",
            "        if ((c - a) * (b - a) < 0)",
            "            return a;",
            "        if ((c - b) * (a - b) < 0)",
            "            return b;",
            "        design_float r = (c - a) * (b - a) / (b - a).length();",
            "        return a + (b - a).unit() * r;",
            "    }",
            "};",
            "namespace Geometry",
            "{",
            "    Point rotate(Point p, Point base, design_float angle)",
            "    {",
            "        return (p - base).rotate(angle) + base;",
            "    }",
            "    Point intersection(Line l1, Line l2)",
            "    {",
            "        design_float s1 = (l2.b - l2.a) ^ (l1.a - l2.a);",
            "        design_float s2 = (l2.b - l2.a) ^ (l1.b - l2.a);",
            "        return (l1.a * s2 - l1.b * s1) / (s2 - s1);",
            "    }",
            "    // 输入一个点集，返回凸包",
            "    vector<Point> getHull(vector<Point> p)",
            "    {",
            "        int n = p.size();",
            "        sort(p.begin(), p.end(), [](Point a, Point b)",
            "             { return a.x == b.x ? a.y < b.y : a.x < b.x; });",
            "        vector<Point> res;",
            "        for (int i = 0; i < n; i++)",
            "        {",
            "            while (res.size() > 1 &&)",
            "            {",
            "                auto v1 = res[res.size() - 1] - res[res.size() - 2];",
            "                auto v2 = p[i] - res[res.size() - 1];",
            "                if ((v1 ^ v2) > eps)",
            "                    break;",
            "                res.pop_back();",
            "            }",
            "            res.push_back(p[i]);",
            "        }",
            "        int t = res.size();",
            "        for (int i = n - 2; i >= 0; i--)",
            "        {",
            "            while (res.size() > 1 &&)",
            "            {",
            "                auto v1 = res[res.size() - 1] - res[res.size() - 2];",
            "                auto v2 = p[i] - res[res.size() - 1];",
            "                if ((v1 ^ v2) > eps)",
            "                    break;",
            "                res.pop_back();",
            "            }",
            "            res.push_back(p[i]);",
            "        }",
            "        res.pop_back();",
            "        return res;",
            "    }",
            "    // 计算凸包的边长",
            "    design_float getHullLength(vector<Point> hull)",
            "    {",
            "        design_float res = 0;",
            "        for (int i = 0; i < hull.size(); i++)",
            "            res += (hull[i] - hull[(i + 1) % hull.size()]).length();",
            "        return res;",
            "    }",
            "    // 计算凸包的面积",
            "    design_float getHullArea(vector<Point> hull)",
            "    {",
            "        design_float res = 0;",
            "        for (int i = 0; i < hull.size(); i++)",
            "            res += (hull[i] ^ hull[(i + 1) % hull.size()]);",
            "        return fabs(res) / 2;",
            "    }",
            "    bool pointOnLeft(Point p, Line l)",
            "    {",
            "        return ((l.b - l.a) ^ (p - l.a)) > eps;",
            "    }",
            "    // 求半平面交，给定若干条有向线段，算法将其排序后，以左边为半平面，返回交的凸包。",
            "    vector<Point> getHalfPlane(vector<Line> lines)",
            "    {",
            "        sort(lines.begin(), lines.end(), [](auto a, auto b)",
            "             {",
            "            design_float angle1 = a.vec().angle(), angle2 = b.vec().angle();",
            "            if (fabs(angle1 - angle2) < eps)",
            "                return pointOnLeft(a.a, b);",
            "            else",
            "                return angle1 < angle2; });",
            "        vector<Line> res;",
            "        for (auto x : lines)",
            "        {",
            "            if (!res.empty() && fabs(x.vec().angle() - res.back().vec().angle()) < eps)",
            "                continue;",
            "            res.push_back(x);",
            "        }",
            "        lines.swap(res);",
            "        int len = lines.size();",
            "        int l = 1, r = 0;",
            "        vector<int> q(len * 2);",
            "        vector<Point> p(len * 2);",
            "        for (int i = 0; i < len; i++)",
            "        {",
            "            while (l < r && !pointOnLeft(p[r], lines[i]))",
            "                r--;",
            "            while (l < r && !pointOnLeft(p[l + 1], lines[i]))",
            "                l++;",
            "            q[++r] = i;",
            "            if (l < r && fabs((lines[q[r]].vec() ^ lines[q[r - 1]].vec())) < eps)",
            "                if (lines[q[r]].vec() * lines[q[r - 1]].vec() < -eps)",
            "                    return vector<Point>();",
            "            if (l < r)",
            "                p[r] = intersection(lines[q[r]], lines[q[r - 1]]);",
            "        }",
            "        while (l < r && !pointOnLeft(p[r], lines[q[l]]))",
            "            r--;",
            "        if (r - l <= 1)",
            "            return vector<Point>();",
            "        p[l] = intersection(lines[q[r]], lines[q[l]]);",
            "        vector<Point> ans;",
            "        while (l <= r)",
            "        {",
            "            ans.push_back(p[l]);",
            "            l++;",
            "        }",
            "        return ans;",
            "    }",
            "}",
            "int main()",
            "{",
            "}"
        ],
        "description": "Snippet from ./数学/计算几何.cpp"
    },
    "NTT": {
        "prefix": "NTT",
        "body": [
            "#include <algorithm>",
            "#include <iostream>",
            "#include <vector>",
            "",
            "typedef long long i64;",
            "",
            "/// quick power",
            "/// @brief",
            "/// @tparam MOD",
            "/// @param x",
            "/// @param y",
            "/// @return",
            "template <i64 MOD>",
            "i64 qpow(i64 x, i64 y)",
            "{",
            "    i64 ans = 1;",
            "    while (y)",
            "    {",
            "        if (y & 1)",
            "            ans = ans * x % MOD;",
            "        x = x * x % MOD;",
            "        y >>= 1;",
            "    }",
            "    return ans;",
            "}",
            "",
            "// make reversed binary representation array",
            "/// @brief",
            "/// @param rev",
            "/// @param len",
            "void makerev(std::vector<int> &rev, const int &len)",
            "{",
            "    rev.resize(len);",
            "    rev[0] = 0;",
            "    rev[1] = len >> 1;",
            "    int l = 0;",
            "    while ((1 << l) < len)",
            "        l++;",
            "    for (int i = 2; i < len; ++i)",
            "        rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (l - 1));",
            "    /*",
            "        rev[i >> 1] is the reversed representation of i >> 1",
            "        (i >> 1) << 1 = i, so in reversed representation we need rev[i >> 1] >> 1",
            "        if i & 1 == 1, then the MSB of reversed representation should be 1",
            "        that is (i & 1) << (l - 1)",
            "    */",
            "}",
            "",
            "// iterative NTT",
            "/// @brief",
            "/// @tparam MOD",
            "/// @param A",
            "/// @param flag",
            "template <i64 MOD>",
            "void NTT(std::vector<i64> &A, const int &flag = 1)",
            "{",
            "    static std::vector<int> rev;",
            "    static const i64 prt = 3, invprt = qpow<MOD>(prt, MOD - 2);",
            "    int n = A.size();",
            "    if (int(rev.size()) != n)",
            "        makerev(rev, n);",
            "    for (int i = 0; i < n; ++i)",
            "        if (rev[i] > i)",
            "            std::swap(A[i], A[rev[i]]);",
            "    for (int len = 2, m = 1; len <= n; m = len, len <<= 1)",
            "    {",
            "        i64 w1 = qpow<MOD>(flag == 1 ? prt : invprt, (MOD - 1) / len), wk;",
            "        for (int l = 0, r = len, k; r <= n; l += len, r += len)",
            "        {",
            "            for (k = l, wk = 1; k < l + m; wk = wk * w1 % MOD, ++k)",
            "            {",
            "                i64 x = A[k], y = A[k + m] * wk % MOD;",
            "                A[k] = (x + y) % MOD;",
            "                A[k + m] = (x - y + MOD) % MOD;",
            "            }",
            "        }",
            "    }",
            "}",
            "",
            "const i64 mod = 998244353;",
            "",
            "signed main(int argc, char **argv)",
            "{",
            "    std::cin.tie(nullptr)->sync_with_stdio(false);",
            "    int n, m, len = 1;",
            "    std::cin >> n >> m;",
            "    while (len <= (n + m))",
            "        len <<= 1; // to make the length a power of 2",
            "    std::vector<i64> A(len), B(len);",
            "    for (int i = 0; i <= n; ++i)",
            "        std::cin >> A[i];",
            "    for (int i = 0; i <= m; ++i)",
            "        std::cin >> B[i];",
            "    NTT<mod>(A);",
            "    NTT<mod>(B);",
            "    for (int i = 0; i < len; ++i)",
            "        A[i] = A[i] * B[i] % mod;",
            "    NTT<mod>(A, -1);",
            "    i64 invlen = qpow<mod>(len, mod - 2);",
            "    for (int i = 0; i <= (n + m); ++i)",
            "        std::cout << A[i] * invlen % mod << ' ';",
            "    std::cout << std::endl;",
            "    return 0;",
            "}"
        ],
        "description": "Snippet from ./数学/NTT.cpp"
    },
    "线性基": {
        "prefix": "线性基",
        "body": [
            "struct Basis",
            "{",
            "#define BITSIZ 63",
            "    typedef unsigned long long ull;",
            "    std::array<ull, BITSIZ> arr;",
            "    int dim = 0;",
            "    Basis()",
            "    {",
            "        fill(arr.begin(), arr.end(), 0);",
            "        dim = 0;",
            "    }",
            "    void insert(ull x)",
            "    {",
            "        for (int i = BITSIZ - 1; i >= 0; i--)",
            "            if ((x >> i) & 1ULL)",
            "                if (arr[i])",
            "                    x ^= arr[i];",
            "                else",
            "                {",
            "                    arr[i] = x;",
            "                    dim++;",
            "                    break;",
            "                }",
            "    }",
            "    void join(Basis b)",
            "    {",
            "        for (int i = 0; i < BITSIZ; i++)",
            "            if (b.arr[i])",
            "                insert(b.arr[i]);",
            "    }",
            "    ull calcMaxNum(ull base = 0)",
            "    {",
            "        for (int i = BITSIZ - 1; i >= 0; i--)",
            "            if ((arr[i] ^ base) > base)",
            "                base ^= arr[i];",
            "        return base;",
            "    }",
            "    // 返回行最简矩阵",
            "    Basis getSimplestForm()",
            "    {",
            "        Basis tmp = *this;",
            "        for (int i = BITSIZ - 1; i >= 0; i--)",
            "        {",
            "            if (tmp.arr[i] == 0)",
            "                continue;",
            "            for (int j = i - 1; j >= 0; j--)",
            "                if ((tmp.arr[i] >> j) & 1ULL)",
            "                    if (tmp.arr[j])",
            "                        tmp.arr[i] ^= tmp.arr[j];",
            "        }",
            "        return tmp;",
            "    }",
            "    ull getDimention()",
            "    {",
            "        return dim;",
            "    }",
            "    // 返回第k小的异或和,  必须是行最简矩阵",
            "    ull calcKthNum(ull k)",
            "    {",
            "        if (k == 0)",
            "            return 0;",
            "        ull ans = 0;",
            "        for (int i = 0; k && i < BITSIZ; i++)",
            "            if (arr[i])",
            "            {",
            "                if (k & 1)",
            "                    ans ^= arr[i];",
            "                k >>= 1;",
            "            }",
            "        if (k)",
            "            return -1;",
            "        return ans;",
            "    }",
            "};"
        ],
        "description": "Snippet from ./数学/线性基.cpp"
    },
    "组合数学": {
        "prefix": "组合数学",
        "body": [
            "#include <bits/stdc++.h>",
            "",
            "const int32_t N = 2e5 + 10;",
            "const int64_t mod = 1e9 + 7;",
            "int64_t fac[N], facRev[N];",
            "auto quickPow(int64_t base, int32_t k)",
            "{",
            "    int64_t ans = 1LL;",
            "    while (k)",
            "    {",
            "        if (k & 1)",
            "            ans = (ans * base) % mod;",
            "        base = (base * base) % mod;",
            "        k >>= 1;",
            "    }",
            "    return ans;",
            "}",
            "void init()",
            "{",
            "    fac[0] = facRev[0] = 1;",
            "    for (int64_t i = 1; i < N; i++)",
            "        fac[i] = fac[i - 1] * i % mod;",
            "    for (int64_t i = 1; i < N; i++)",
            "        facRev[i] = quickPow(fac[i], mod - 2);",
            "}",
            "int64_t C(int n, int m)",
            "{",
            "    return fac[n] * facRev[m] % mod * facRev[n - m] % mod;",
            "}"
        ],
        "description": "Snippet from ./数学/组合数学.cpp"
    }
}