{
    "默认模板": {
        "prefix": "默认模板",
        "body": [
            "// #pragma GCC optimize(\"Ofast,no-stack-protector\")",
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "typedef long long ll;",
            "typedef double db;",
            "typedef pair<int, int> pii;",
            "typedef pair<ll, ll> pll;",
            "typedef pair<db, db> pdd;",
            "typedef pair<ll, int> pli;",
            "",
            "const int N = 2e5 + 10;",
            "const int inf = 1 << 30;",
            "const ll inf64 = 1ll << 60;",
            "const double PI = acos(-1);",
            "",
            "#define lowbit(x) (x & -x)",
            "",
            "int n, m, k, q;",
            "",
            "void work()",
            "{",
            "    cin >> n;",
            "}",
            "int main()",
            "{",
            "    cin.tie(nullptr)->sync_with_stdio(false);",
            "    int t;",
            "    cin >> t;",
            "    while (t-- > 0)",
            "    {",
            "        work();",
            "    }",
            "}"
        ],
        "description": "Snippet from ./默认模板.cpp"
    },
    "Dinic费用流": {
        "prefix": "Dinic费用流",
        "body": [
            "#include <bits/stdc++.h>",
            "namespace Dinic",
            "{",
            "    using T = int64_t;",
            "    const int NODE = 1e5 + 10;",
            "    const int EDGE = 1e5 + 10;",
            "    struct Edge",
            "    {",
            "        int to, nxt;",
            "        T flow, cost;",
            "        // flow剩余流量",
            "        // cost通过费用",
            "    } edge[EDGE];",
            "    int head[NODE];      // 邻接表头",
            "    int cnt = 1;         // 总边数",
            "    int pre[NODE];       // 表示当前增广路中每个节点的上一个节点",
            "    T flow[NODE];        // 到达当前节点的总流量",
            "    T cost[NODE];        // 到达当前节点的总花费",
            "    int last[NODE];      // 到达上一节点的边的编号",
            "    std::queue<int> que; // SPFA用队列",
            "    bool vis[NODE];      // 当前节点是否走过",
            "    int start, end;",
            "    void add(int x, int y, T flow, T cost)",
            "    {",
            "        edge[++cnt] = Edge{y, head[x], flow, cost};",
            "        head[x] = cnt;",
            "        edge[++cnt] = Edge{x, head[y], 0, -cost};",
            "        head[y] = cnt;",
            "    }",
            "    bool spfa()",
            "    {",
            "        memset(flow, 0x3f, sizeof flow);",
            "        memset(cost, 0x3f, sizeof cost);",
            "        memset(vis, 0, sizeof vis);",
            "        que.push(start);",
            "        pre[end] = -1;",
            "        cost[start] = 0;",
            "        vis[start] = 1;",
            "        while (!que.empty())",
            "        {",
            "            int x = que.front();",
            "            que.pop();",
            "            vis[x] = 0;",
            "            for (int i = head[x]; i; i = edge[i].nxt)",
            "            {",
            "                int y = edge[i].to;",
            "                if (edge[i].flow > 0 && cost[y] > cost[x] + edge[i].cost)",
            "                {",
            "                    flow[y] = std::min(flow[x], edge[i].flow);",
            "                    cost[y] = cost[x] + edge[i].cost;",
            "                    last[y] = i;",
            "                    pre[y] = x;",
            "                    if (!vis[y])",
            "                    {",
            "                        vis[y] = 1;",
            "                        que.push(y);",
            "                    }",
            "                }",
            "            }",
            "        }",
            "        return pre[end] != -1;",
            "    }",
            "    std::pair<T, T> work()",
            "    {",
            "        int maxflow = 0, mincost = 0;",
            "        while (spfa())",
            "        {",
            "            maxflow += flow[end];",
            "            mincost += cost[end] * flow[end];",
            "            int now = end;",
            "            while (now != start)",
            "            {",
            "                edge[last[now]].flow -= flow[end];",
            "                edge[last[now] ^ 1].flow += flow[end];",
            "                now = pre[now];",
            "            }",
            "        }",
            "        return {maxflow, mincost};",
            "    }",
            "}"
        ],
        "description": "Snippet from ./图论/网络流/Dinic费用流.cpp"
    },
    "Dinic最大流": {
        "prefix": "Dinic最大流",
        "body": [
            "#include <bits/stdc++.h>",
            "namespace Dinic",
            "{",
            "",
            "    using T = int32_t;",
            "    // 定义储存流量的类型，默认为int32_t",
            "    const int CNT_NODE = 2e5 + 10;",
            "    // 定义节点Node的数量",
            "    const int CNT_EDGE = 2e5 + 10;",
            "    // 定义边的数量",
            "    struct Edge",
            "    {",
            "        int to;",
            "        int nxt;",
            "        T flow;",
            "    } e[CNT_EDGE];",
            "    int head[CNT_NODE], cnt = 1;",
            "    int n;",
            "    void add(int x, int y, T flow)",
            "    {",
            "        e[++cnt] = Edge{y, head[x], flow};",
            "        head[x] = cnt;",
            "        e[++cnt] = Edge{x, head[y], 0};",
            "        head[y] = cnt;",
            "        n = std::max(n, x);",
            "        n = std::max(n, y);",
            "    }",
            "    int st, ed;",
            "    T dis[CNT_NODE];",
            "    int cur[CNT_NODE];",
            "    bool bfs()",
            "    {",
            "        std::queue<int> que;",
            "        que.push(ed);",
            "        memset(dis, 0, sizeof(dis));",
            "        dis[ed] = 1;",
            "        while (!que.empty())",
            "        {",
            "            auto x = que.front();",
            "            que.pop();",
            "            cur[x] = head[x];",
            "            for (auto i = head[x]; i; i = e[i].nxt)",
            "            {",
            "                auto y = e[i].to;",
            "                if (!dis[y] && e[i ^ 1].flow)",
            "                {",
            "                    dis[y] = dis[x] + 1;",
            "                    que.push(y);",
            "                }",
            "            }",
            "        }",
            "        return dis[st];",
            "    }",
            "    T dfs(int x, T flow)",
            "    {",
            "        auto rest = flow;",
            "        if (!flow || x == ed)",
            "            return flow;",
            "        for (auto &i = cur[x]; i && rest; i = e[i].nxt)",
            "        {",
            "            auto y = e[i].to;",
            "            if (dis[y] == dis[x] - 1 && e[i].flow)",
            "            {",
            "                auto k = dfs(y, std::min(rest, e[i].flow));",
            "                e[i].flow -= k;",
            "                e[i ^ 1].flow += k;",
            "                rest -= k;",
            "            }",
            "        }",
            "        return flow - rest;",
            "    }",
            "    T dinic()",
            "    {",
            "        for (int i = 1; i <= n; i++)",
            "            cur[i] = head[i];",
            "        T ans = 0, k;",
            "        while (bfs())",
            "            while (k = dfs(st, 0x3f3f3f3f))",
            "                ans += k;",
            "        return ans;",
            "    }",
            "}"
        ],
        "description": "Snippet from ./图论/网络流/Dinic最大流.cpp"
    },
    "Dijkstra": {
        "prefix": "Dijkstra",
        "body": [
            "#include <bits/stdc++.h>",
            "const int N = 2e5 + 10;",
            "",
            "namespace Graph",
            "{",
            "    typedef int64_t T;",
            "    typedef std::pair<int64_t, int32_t> pli;",
            "    std::vector<pli> to[N];",
            "    void add(int x, int y, T val)",
            "    {",
            "        to[x].push_back({val, y});",
            "    }",
            "    bool vis[N];",
            "    T dis[N];",
            "    void shortest_path(int32_t from)",
            "    {",
            "        // using Dijkstra",
            "        std::priority_queue<pli, std::vector<pli>, std::greater<pli>> q;",
            "        q.push(std::make_pair(0, from));",
            "        memset(dis, 0x3f, sizeof dis);",
            "        memset(vis, 0, sizeof vis);",
            "        dis[from] = 0;",
            "        while (!q.empty())",
            "        {",
            "            auto [nowval, x] = q.top();",
            "            q.pop();",
            "            if (vis[x])",
            "                continue;",
            "            vis[x] = 1;",
            "            for (auto [val, y] : to[x])",
            "                if (dis[y] > dis[x] + val)",
            "                {",
            "                    dis[y] = dis[x] + val;",
            "                    q.push(std::make_pair(dis[y], y));",
            "                }",
            "        }",
            "    }",
            "}"
        ],
        "description": "Snippet from ./图论/最短路/Dijkstra.cpp"
    },
    "普通Splay": {
        "prefix": "普通Splay",
        "body": [
            "template <class T>",
            "class SplayTree",
            "{",
            "private:",
            "#define LEFTSON 0",
            "#define RIGHTSON 1",
            "    struct Node",
            "    {",
            "        T val;",
            "        int son[2];",
            "        int fa;",
            "        int siz;",
            "        Node()",
            "        {",
            "            val = T();",
            "            son[LEFTSON] = son[RIGHTSON] = 0;",
            "            fa = siz = 0;",
            "        }",
            "        Node(T val, int cnt = 1)",
            "        {",
            "            this->val = val;",
            "            this->siz = 1;",
            "            this->son[0] = this->son[1] = 0;",
            "        }",
            "    };",
            "    vector<Node> tr;",
            "    int root;",
            "    /* 更新旋转后节点的信息 */",
            "    void update(int x)",
            "    {",
            "        tr[x].siz = tr[tr[x].son[LEFTSON]].siz + tr[tr[x].son[RIGHTSON]].siz + 1;",
            "    }",
            "    /*返回当前编号的节点是左节点还是右节点*/",
            "    int identify(int x)",
            "    {",
            "        if (tr[tr[x].fa].son[1] == x)",
            "            return RIGHTSON;",
            "        else",
            "            return LEFTSON;",
            "    }",
            "    /*根据情况进行左旋Zig或者右旋Zag*/",
            "    void rotate(int x)",
            "    {",
            "        int y = tr[x].fa, z = tr[y].fa;",
            "        int type = identify(x), typeY = 0;",
            "        if (z)",
            "            tr[z].son[identify(y)] = x;",
            "        tr[y].son[type] = tr[x].son[!type];",
            "        if (tr[x].son[!type])",
            "            tr[tr[x].son[!type]].fa = y;",
            "        tr[x].son[!type] = y;",
            "        tr[y].fa = x;",
            "        tr[x].fa = z;",
            "        update(y);",
            "        update(x);",
            "    }",
            "    /*伸展操作，将节点旋转至目标点*/",
            "    void splay(int x, int target = 0)",
            "    {",
            "        if (x == target)",
            "            return;",
            "        while (tr[x].fa != target)",
            "        {",
            "            int y = tr[x].fa;",
            "            if (tr[y].fa == 0) // 单Zig/Zag",
            "                rotate(x);",
            "            else",
            "            {",
            "                int typeX = identify(x), typeY = identify(y);",
            "                if (typeX == typeY) // 同向，ZigZig/ZagZag",
            "                {",
            "                    rotate(y);",
            "                    rotate(x);",
            "                }",
            "                else // 异向，ZigZag/ZagZig",
            "                {",
            "                    rotate(x);",
            "                    rotate(x);",
            "                }",
            "            }",
            "        }",
            "        if (target == 0)",
            "            root = x;",
            "    }",
            "",
            "public:",
            "    SplayTree()",
            "    {",
            "        tr.clear();",
            "        tr.push_back(Node());",
            "        root = 0;",
            "    }",
            "    void insert(T x)",
            "    {",
            "        if (root == 0)",
            "        {",
            "            tr.push_back(Node(x));",
            "            root = tr.size() - 1;",
            "        }",
            "        else",
            "        {",
            "            int p = root, pf = 0;",
            "            bool type = 0;",
            "            while (p)",
            "            {",
            "                pf = p;",
            "                type = x > tr[p].val;",
            "                p = tr[p].son[type];",
            "            }",
            "            tr.push_back(Node(x));",
            "            p = tr.size() - 1;",
            "            tr[pf].son[type] = p;",
            "            tr[p].fa = pf;",
            "            splay(p);",
            "        }",
            "    }",
            "    void remove(T val)",
            "    {",
            "        int p = root, pf = 0;",
            "        while (p && tr[p].val != val)",
            "        {",
            "            pf = p;",
            "            p = tr[p].son[val > tr[p].val];",
            "        }",
            "        if (!p)",
            "        {",
            "            if (pf)",
            "                splay(pf);",
            "            return;",
            "        }",
            "        splay(p);",
            "        int cur = tr[p].son[0];",
            "        if (cur == 0)",
            "        {",
            "            root = tr[p].son[1];",
            "            tr[root].fa = 0;",
            "            tr[p] = Node();",
            "            return;",
            "        }",
            "        root = cur;",
            "        while (tr[cur].son[1])",
            "            cur = tr[cur].son[1];",
            "        tr[cur].son[1] = tr[p].son[1];",
            "        tr[tr[p].son[1]].fa = cur;",
            "        tr[root].fa = 0;",
            "        tr[p] = Node();",
            "        splay(cur);",
            "    }",
            "    T find_by_rank(int rank)",
            "    {",
            "        int nowRank = 0, p = root;",
            "        while (true)",
            "        {",
            "            if (nowRank + tr[tr[p].son[0]].siz + 1 == rank)",
            "            {",
            "                splay(p);",
            "                return tr[p].val;",
            "            }",
            "            else if (nowRank + tr[tr[p].son[0]].siz >= rank)",
            "                p = tr[p].son[0];",
            "            else",
            "            {",
            "                nowRank += tr[tr[p].son[0]].siz + 1;",
            "                p = tr[p].son[1];",
            "            }",
            "        }",
            "    }",
            "    int order_by_rank(T val)",
            "    {",
            "        int rank = 0, p = root, pf = 0;",
            "        while (p != 0)",
            "        {",
            "            pf = p;",
            "            if (tr[p].val < val)",
            "            {",
            "                rank += tr[tr[p].son[0]].siz + 1;",
            "                p = tr[p].son[1];",
            "            }",
            "            else",
            "                p = tr[p].son[0];",
            "        }",
            "        splay(pf);",
            "        return rank + 1;",
            "    }",
            "    T prev(T val)",
            "    {",
            "        T ans = T();",
            "        int p = root, pf = 0;",
            "        while (p != 0)",
            "        {",
            "            pf = p;",
            "            if (tr[p].val >= val)",
            "                p = tr[p].son[0];",
            "            else",
            "            {",
            "                ans = tr[p].val;",
            "                p = tr[p].son[1];",
            "            }",
            "        }",
            "        splay(pf);",
            "        return ans;",
            "    }",
            "    T next(T val)",
            "    {",
            "        T ans = T();",
            "        int p = root, pf = 0;",
            "        while (p != 0)",
            "        {",
            "            pf = p;",
            "            if (tr[p].val <= val)",
            "                p = tr[p].son[1];",
            "            else",
            "            {",
            "                ans = tr[p].val;",
            "                p = tr[p].son[0];",
            "            }",
            "        }",
            "        splay(pf);",
            "        return ans;",
            "    }",
            "#undef LEFTSON",
            "#undef RIGHTSON",
            "};"
        ],
        "description": "Snippet from ./数据结构/普通Splay.cpp"
    },
    "树链剖分": {
        "prefix": "树链剖分",
        "body": [
            "template <class T>",
            "struct SegmentTree",
            "{",
            "    struct Node",
            "    {",
            "        T val, lazy;",
            "        int l, r;",
            "    };",
            "    vector<Node> tr;",
            "    void update(int p)",
            "    {",
            "        tr[p].val = (tr[p << 1].val + tr[p << 1 | 1].val);",
            "    }",
            "    void build(int l, int r, vector<T> &a, int p = 1)",
            "    {",
            "",
            "        tr[p].l = l;",
            "        tr[p].r = r;",
            "        tr[p].lazy = 0;",
            "        if (l == r)",
            "        {",
            "            tr[p].val = a[l];",
            "            return;",
            "        }",
            "        int mid = (l + r) >> 1;",
            "        build(l, mid, a, p << 1);",
            "        build(mid + 1, r, a, p << 1 | 1);",
            "        update(p);",
            "    }",
            "    SegmentTree() {}",
            "    SegmentTree(int n)",
            "    {",
            "        tr.resize(n * 4);",
            "        vector<T> empty(n);",
            "        build(0, n - 1, empty);",
            "    }",
            "    SegmentTree(vector<T> &a)",
            "    {",
            "        int n = a.size();",
            "        tr.resize(n * 4);",
            "        build(0, n - 1, a);",
            "    }",
            "    void pushdown(int p)",
            "    {",
            "        if (tr[p].lazy)",
            "        {",
            "            T t = tr[p].lazy;",
            "            tr[p << 1].val += t * (tr[p << 1].r - tr[p << 1].l + 1);",
            "            tr[p << 1].lazy += t;",
            "            tr[p << 1 | 1].val += t * (tr[p << 1 | 1].r - tr[p << 1 | 1].l + 1);",
            "            tr[p << 1 | 1].lazy += t;",
            "            tr[p].lazy = 0;",
            "        }",
            "    }",
            "    T query(int l, int r, int p = 1)",
            "    {",
            "        if (l <= tr[p].l && tr[p].r <= r)",
            "            return tr[p].val;",
            "        int mid = (tr[p].l + tr[p].r) >> 1;",
            "        T sum = 0;",
            "        pushdown(p);",
            "        if (l <= mid)",
            "            sum += query(l, r, p << 1);",
            "        if (mid < r)",
            "            sum += query(l, r, p << 1 | 1);",
            "        return sum;",
            "    }",
            "    void add(int l, int r, int val, int p = 1)",
            "    {",
            "        if (l <= tr[p].l && tr[p].r <= r)",
            "        {",
            "            tr[p].val += (tr[p].r - tr[p].l + 1) * val;",
            "            tr[p].lazy += val;",
            "            return;",
            "        }",
            "        pushdown(p);",
            "        int mid = (tr[p].l + tr[p].r) >> 1;",
            "        if (l <= mid)",
            "            add(l, r, val, p << 1);",
            "        if (mid < r)",
            "            add(l, r, val, p << 1 | 1);",
            "        update(p);",
            "    }",
            "};",
            "template <class T>",
            "struct ChainPartition",
            "{",
            "    vector<vector<int>> son;",
            "    vector<int> dep, top, siz, hson, lnk2seg, lnk2tree, f;",
            "    vector<T> segval, treeval;",
            "    int dfnCount;",
            "    SegmentTree<T> tr;",
            "    ChainPartition() {}",
            "    ChainPartition(int n)",
            "    {",
            "        dfnCount = 0;",
            "        segval.resize(n);",
            "        f.resize(n);",
            "        dep.resize(n);",
            "        top.resize(n);",
            "        siz.resize(n);",
            "        hson.resize(n);",
            "        lnk2seg.resize(n);",
            "        lnk2tree.resize(n);",
            "        son.resize(n);",
            "        tr = SegmentTree<T>(n);",
            "    }",
            "    ChainPartition(vector<T> a)",
            "    {",
            "        int n = a.size();",
            "        dfnCount = 0;",
            "        segval.resize(n);",
            "        f.resize(n);",
            "        dep.resize(n);",
            "        top.resize(n);",
            "        siz.resize(n);",
            "        hson.resize(n);",
            "        lnk2seg.resize(n);",
            "        lnk2tree.resize(n);",
            "        son.resize(n);",
            "        treeval = a;",
            "    }",
            "    void addEdge(int x, int y)",
            "    {",
            "        son[x].push_back(y);",
            "        son[y].push_back(x);",
            "    }",
            "    void dfs1(int x, int fa, int depth = 1)",
            "    {",
            "        dep[x] = depth;",
            "        siz[x] = 1;",
            "        hson[x] = -1;",
            "        f[x] = fa;",
            "        for (int y : son[x])",
            "        {",
            "            if (y == fa)",
            "                continue;",
            "            dfs1(y, x, depth + 1);",
            "            siz[x] += siz[y];",
            "            if (hson[x] == -1 || siz[hson[x]] < siz[y])",
            "                hson[x] = y;",
            "        }",
            "    }",
            "    void dfs2(int x, int nowtop)",
            "    {",
            "        top[x] = nowtop;",
            "        lnk2seg[x] = dfnCount++;",
            "        lnk2tree[lnk2seg[x]] = x;",
            "        segval[lnk2seg[x]] = treeval[x];",
            "        if (hson[x] == -1)",
            "            return;",
            "        dfs2(hson[x], nowtop);",
            "        for (int y : son[x])",
            "        {",
            "            if (y == f[x] || y == hson[x])",
            "                continue;",
            "            dfs2(y, y);",
            "        }",
            "    }",
            "    void init(int root = 0)",
            "    {",
            "        dfs1(root, -1);",
            "        dfs2(root, root);",
            "        tr = SegmentTree(segval);",
            "    }",
            "    T querySubtree(int x)",
            "    {",
            "        return tr.query(lnk2seg[x], lnk2seg[x] + siz[x] - 1);",
            "    }",
            "    void addSubtree(int x, T val)",
            "    {",
            "        tr.add(lnk2seg[x], lnk2seg[x] + siz[x] - 1, val);",
            "    }",
            "    int getLCA(int x, int y)",
            "    {",
            "        while (top[x] != top[y])",
            "        {",
            "            if (dep[top[x]] < dep[top[y]])",
            "                swap(x, y);",
            "            x = f[top[x]];",
            "        }",
            "        if (dep[x] < dep[y])",
            "            return x;",
            "        else",
            "            return y;",
            "    }",
            "    void add(int x, int y, T val)",
            "    {",
            "        while (top[x] != top[y])",
            "        {",
            "            if (dep[top[x]] < dep[top[y]])",
            "                swap(x, y);",
            "            tr.add(lnk2seg[top[x]], lnk2seg[x], val);",
            "            x = f[top[x]];",
            "        }",
            "        if (dep[x] > dep[y])",
            "            swap(x, y);",
            "        tr.add(lnk2seg[x], lnk2seg[y], val);",
            "    }",
            "    T query(int x, int y)",
            "    {",
            "        T ans = 0;",
            "        while (top[x] != top[y])",
            "        {",
            "            if (dep[top[x]] < dep[top[y]])",
            "                swap(x, y);",
            "            ans += tr.query(lnk2seg[top[x]], lnk2seg[x]);",
            "            x = f[top[x]];",
            "        }",
            "        if (dep[x] > dep[y])",
            "            swap(x, y);",
            "        ans += tr.query(lnk2seg[x], lnk2seg[y]);",
            "        return ans;",
            "    }",
            "};"
        ],
        "description": "Snippet from ./数据结构/树链剖分.cpp"
    },
    "二维数组（带越界检查）": {
        "prefix": "二维数组（带越界检查）",
        "body": [
            "/*",
            " * 类模板实现的二维矩阵",
            " * 实现功能：",
            " * 1. 当数组越界时返回缺省值而非直接报错",
            " * 2. 通过成员函数获取行列数",
            " */",
            "",
            "template <typename T>",
            "class Matrix",
            "{",
            "private:",
            "public:",
            "    Matrix(size_t rows, size_t cols, const T &initial_value = T())",
            "        : rows_(rows), cols_(cols), data_(rows, std::vector<T>(cols, initial_value)) {}",
            "",
            "    // 重载()运算符用于访问行列列",
            "    T &operator()(size_t row, size_t col)",
            "    {",
            "        if (row < 0 || row >= rows_ || col < 0 || col >= cols_)",
            "        {",
            "            // std::cerr << \"Error: Index out of bounds\\n\";",
            "            //  返回一个默认值，默认为0。",
            "            static T default_value = 0;",
            "            return default_value;",
            "        }",
            "        return data_[row][col];",
            "    }",
            "",
            "    // 用于获取行数和列数的函数",
            "    size_t rows() const",
            "    {",
            "        return rows_;",
            "    }",
            "",
            "    size_t cols() const",
            "    {",
            "        return cols_;",
            "    }",
            "",
            "private:",
            "    size_t rows_;",
            "    size_t cols_;",
            "    std::vector<std::vector<T>> data_;",
            "};"
        ],
        "description": "Snippet from ./数据结构/二维数组（带越界检查）.cpp"
    },
    "线段树": {
        "prefix": "线段树",
        "body": [
            "#include <cstdint>",
            "/*",
            " * 线段树模板",
            " * 默认为区间加法",
            " * 注意：默认下标从0开始，范围[0, n)",
            " */",
            "template <class T>",
            "struct SegmentTree",
            "{",
            "    struct Node",
            "    {",
            "        T val, lazy;",
            "        int l, r;",
            "    };",
            "    vector<Node> tr;",
            "    void updata(int p)",
            "    {",
            "        tr[p].val = tr[p << 1].val + tr[p << 1 | 1].val;",
            "    }",
            "    void build(int l, int r, vector<T> &a, int p = 1)",
            "    {",
            "        if (l == r)",
            "        {",
            "            tr[p].l = tr[p].r = l;",
            "            tr[p].val = a[l];",
            "            return;",
            "        }",
            "        int mid = (l + r) >> 1;",
            "        build(l, mid, a, p << 1);",
            "        build(mid + 1, r, a, p << 1 | 1);",
            "        tr[p].l = l, tr[p].r = r;",
            "        updata(p);",
            "    }",
            "    SegmentTree(int n)",
            "    {",
            "        tr.clear();",
            "        tr.resize(n * 4);",
            "        build(0, n - 1, vector<T>(n));",
            "    }",
            "    SegmentTree(vector<T> &a)",
            "    {",
            "        int n = a.size();",
            "        tr.clear();",
            "        tr.resize(n * 4);",
            "        build(0, n - 1, a);",
            "    }",
            "",
            "    void spread(int p)",
            "    {",
            "        if (tr[p].lazy)",
            "        {",
            "            T t = tr[p].lazy;",
            "            tr[p << 1].val += t * (tr[p << 1].r - tr[p << 1].l + 1), tr[p << 1].lazy += t;",
            "            tr[p << 1 | 1].val += t * (tr[p << 1 | 1].r - tr[p << 1 | 1].l + 1), tr[p << 1 | 1].lazy += t;",
            "            tr[p].lazy = 0;",
            "        }",
            "    }",
            "    T query(int l, int r, int p = 1)",
            "    {",
            "        if (l <= tr[p].l && tr[p].r <= r)",
            "            return tr[p].val;",
            "        int mid = (tr[p].l + tr[p].r) >> 1;",
            "        T sum = 0;",
            "        spread(p);",
            "        if (l <= mid)",
            "            sum += query(l, r, p << 1);",
            "        if (mid < r)",
            "            sum += query(l, r, p << 1 | 1);",
            "        return sum;",
            "    }",
            "    void add(int l, int r, int val, int p = 1)",
            "    {",
            "        if (l <= tr[p].l && tr[p].r <= r)",
            "        {",
            "            tr[p].val += (tr[p].r - tr[p].l + 1) * val;",
            "            tr[p].lazy += val;",
            "            return;",
            "        }",
            "        spread(p);",
            "        int mid = (tr[p].l + tr[p].r) >> 1;",
            "        if (l <= mid)",
            "            add(l, r, val, p << 1);",
            "        if (mid < r)",
            "            add(l, r, val, p << 1 | 1);",
            "        updata(p);",
            "    }",
            "};"
        ],
        "description": "Snippet from ./数据结构/线段树.cpp"
    },
    "ST表": {
        "prefix": "ST表",
        "body": [
            "#include <vector>",
            "#include <cstdint>",
            "#include <algorithm>",
            "/*",
            " * RMQ算法模板",
            " * 默认维护区间最大值",
            " */",
            "namespace RMQ",
            "{",
            "    typedef int32_t T;",
            "    // 维护值的类型，默认为int32_t",
            "    std::vector<std::vector<T>> _data;",
            "    // 预处理出log2以提速",
            "    std::vector<int32_t> lg2;",
            "    // 定义维护的信息，默认为max",
            "    T func(T x, T y)",
            "    {",
            "        return std::max(x, y);",
            "    }",
            "    void init(std::vector<T> a)",
            "    {",
            "        int n = a.size();",
            "        lg2 = std::vector<int>(n + 1);",
            "        lg2[1] = 0;",
            "        for (int i = 2; i <= n; i++)",
            "            lg2[i] = lg2[i >> 1] + 1;",
            "        _data = std::vector<std::vector<int>>(n, std::vector<int>(lg2[n] + 1));",
            "        for (int i = 0; i < n; i++)",
            "            _data[i][0] = a[i];",
            "        for (int bit = 1; bit <= lg2[n]; bit++)",
            "            for (int i = 0; i + (1 << bit) - 1 < n; i++)",
            "                _data[i][bit] = func(_data[i][bit - 1], _data[i + (1 << (bit - 1))][bit - 1]);",
            "    }",
            "    T query(size_t l, size_t r)",
            "    {",
            "        int32_t bit = lg2[r - l + 1];",
            "        return func(_data[l][bit], _data[r - (1 << bit) + 1][bit]);",
            "    }",
            "}"
        ],
        "description": "Snippet from ./数据结构/ST表.cpp"
    },
    "DSU并查集": {
        "prefix": "DSU并查集",
        "body": [
            "struct DSU",
            "{",
            "    vector<int> f, siz;",
            "    DSU() {}",
            "    DSU(int n)",
            "    {",
            "        f.resize(n + 1);",
            "        siz.resize(n + 1);",
            "        for (int i = 1; i <= n; i++)",
            "            f[i] = i, siz[i] = 1;",
            "    }",
            "    int find(int x)",
            "    {",
            "        return f[x] == x ? x : f[x] = find(f[x]);",
            "    }",
            "    void merge(int x, int y)",
            "    {",
            "        x = find(x);",
            "        y = find(y);",
            "        if (x == y)",
            "            return;",
            "        f[x] = y;",
            "        siz[y] += siz[x];",
            "    }",
            "};"
        ],
        "description": "Snippet from ./数据结构/DSU并查集.cpp"
    },
    "LCT": {
        "prefix": "LCT",
        "body": [
            "#include <algorithm>",
            "#include <iostream>",
            "#include <vector>",
            "/*",
            " * LCT模板",
            " * Info 表示值，Tag 表示标记",
            " */",
            "template <typename _Info, typename _Tag>",
            "class LCT",
            "{",
            "public:",
            "    LCT() : m_size(0) {}",
            "    LCT(const int &_n, const _Info &_v = _Info())",
            "    {",
            "        init(_n, _v);",
            "    }",
            "    LCT(const std::vector<_Info> &_init)",
            "    {",
            "        init(_init);",
            "    }",
            "    void init(const int &_n, const _Info &_v = _Info())",
            "    {",
            "        init(std::vector<_Info>(_n, _v));",
            "    }",
            "    void init(const std::vector<_Info> &_init)",
            "    {",
            "        resize(_init.size());",
            "        for (size_t i = 0; i < m_size; ++i)",
            "            val[i + 1] = _init[i];",
            "    }",
            "    void resize(const size_t &s)",
            "    {",
            "        m_size = s;",
            "        fa.resize(m_size + 1);",
            "        siz.resize(m_size + 1);",
            "        ch.resize(m_size + 1);",
            "        sta.resize(m_size + 1);",
            "        rev.resize(m_size + 1);",
            "        val.resize(m_size + 1);",
            "        sum.resize(m_size + 1);",
            "        tag.resize(m_size + 1);",
            "        for (size_t i = 0; i <= m_size; ++i)",
            "            ch[i].resize(2);",
            "    }",
            "    size_t size() const { return m_size; }",
            "    bool empty() const { return !m_size; }",
            "    int findroot(int x)",
            "    {",
            "        access(x);",
            "        _splay(x);",
            "        while (ch[x][0])",
            "        {",
            "            pushdown(x);",
            "            x = ch[x][0];",
            "        }",
            "        _splay(x);",
            "        return x;",
            "    }",
            "    void makeroot(const int &x)",
            "    {",
            "        access(x);",
            "        _splay(x);",
            "        flip(x);",
            "    }",
            "    void link(const int &x, const int &y)",
            "    {",
            "        makeroot(x);",
            "        if (findroot(y) != x)",
            "            fa[x] = y;",
            "    }",
            "    void cut(const int &x, const int &y)",
            "    {",
            "        _split(x, y);",
            "        if (findroot(y) == x && fa[y] == x && !ch[y][0])",
            "        {",
            "            fa[y] = ch[x][1] = 0;",
            "            pushup(x);",
            "        }",
            "    }",
            "    void set(const int &x, const _Info &v = _Info())",
            "    {",
            "        _splay(x);",
            "        val[x] = v;",
            "        pushup(x);",
            "    }",
            "    void change(const int &x, const int &y, const _Tag &v)",
            "    {",
            "        _split(x, y);",
            "        apply(y, v);",
            "    }",
            "    _Info asksum(const int &x, const int &y)",
            "    {",
            "        _split(x, y);",
            "        return sum[y];",
            "    }",
            "",
            "private:",
            "    std::vector<int> fa, siz;",
            "    std::vector<std::vector<int>> ch;",
            "    std::vector<int> sta, rev;",
            "    std::vector<_Info> val, sum;",
            "    std::vector<_Tag> tag;",
            "    size_t m_size;",
            "    bool relation(const int &x) const",
            "    {",
            "        return ch[fa[x]][0] == x || ch[fa[x]][1] == x;",
            "    }",
            "    void pushup(const int &x)",
            "    {",
            "        sum[x] = sum[ch[x][0]] + val[x] + sum[ch[x][1]];",
            "        siz[x] = siz[ch[x][0]] + siz[ch[x][1]] + 1;",
            "    }",
            "    void flip(const int &x)",
            "    {",
            "        std::swap(ch[x][0], ch[x][1]);",
            "        rev[x] ^= 1;",
            "    }",
            "    void apply(const int &x, const _Tag &t)",
            "    {",
            "        val[x].apply(t);",
            "        sum[x].apply(t);",
            "        tag[x].apply(t);",
            "    }",
            "    void pushdown(const int &x)",
            "    {",
            "        if (rev[x])",
            "        {",
            "            if (ch[x][0])",
            "                flip(ch[x][0]);",
            "            if (ch[x][1])",
            "                flip(ch[x][1]);",
            "            rev[x] = 0;",
            "        }",
            "        if (ch[x][0])",
            "            apply(ch[x][0], tag[x]);",
            "        if (ch[x][1])",
            "            apply(ch[x][1], tag[x]);",
            "        tag[x] = _Tag();",
            "    }",
            "    void _rotate(const int &x)",
            "    {",
            "        int y = fa[x], z = fa[y], k = (ch[y][1] == x), v = ch[x][!k];",
            "        if (relation(y))",
            "            ch[z][ch[z][1] == y] = x;",
            "        ch[x][!k] = y;",
            "        ch[y][k] = v;",
            "        if (v)",
            "            fa[v] = y;",
            "        fa[y] = x;",
            "        fa[x] = z;",
            "        pushup(y);",
            "        pushup(x);",
            "    }",
            "    void _splay(int x)",
            "    {",
            "        int y = x, top = 1;",
            "        sta[top] = x;",
            "        while (relation(y))",
            "            sta[++top] = y = fa[y];",
            "        while (top)",
            "            pushdown(sta[top--]);",
            "        while (relation(x))",
            "        {",
            "            y = fa[x];",
            "            top = fa[y];",
            "            if (relation(y))",
            "                _rotate((ch[y][1] == x) == (ch[top][1] == y) ? y : x);",
            "            _rotate(x);",
            "        }",
            "        pushup(x);",
            "    }",
            "    void access(int x)",
            "    {",
            "        for (int y = 0; x; y = x, x = fa[x])",
            "        {",
            "            _splay(x);",
            "            ch[x][1] = y;",
            "            pushup(x);",
            "        }",
            "    }",
            "    void _split(const int &x, const int &y)",
            "    {",
            "        makeroot(x);",
            "        access(y);",
            "        _splay(y);",
            "    }",
            "};",
            "typedef long long i64;",
            "const i64 mod = 998244353;",
            "struct Tag",
            "{",
            "    i64 add, mul;",
            "    Tag(i64 vadd = 0, i64 vmul = 1) : add(vadd), mul(vmul) {}",
            "    void apply(const Tag &v)",
            "    {",
            "        mul *= v.mul;",
            "        mul %= mod;",
            "        add *= v.mul;",
            "        add += v.add;",
            "        add %= mod;",
            "    }",
            "};",
            "struct Info",
            "{",
            "    i64 sum, siz;",
            "    Info(i64 v = 0, i64 z = 0) : sum(v % mod), siz(z) {}",
            "    void apply(const Tag &v)",
            "    {",
            "        sum = (sum * v.mul % mod + v.add * siz % mod) % mod;",
            "    }",
            "    Info operator+(const Info &b) const",
            "    {",
            "        return Info(sum + b.sum, siz + b.siz);",
            "    }",
            "};",
            "LCT<Info, Tag> tr;"
        ],
        "description": "Snippet from ./数据结构/LCT.cpp"
    },
    "李超线段树": {
        "prefix": "李超线段树",
        "body": [
            "/*",
            " * 李超线段树模板",
            " * 要求参数均为整数",
            " */",
            "typedef long long i64;",
            "template <int LEN>",
            "class Lichao_SegmentTree",
            "{",
            "public:",
            "    const i64 inf = 0x3f3f3f3f3f3f3f3f;",
            "    struct Line",
            "    {",
            "        i64 k, b;",
            "        Line(i64 _k = 0, i64 _b = 0) : k(_k), b(_b) {}",
            "        i64 at(i64 x) const { return k * x + b; }",
            "    };",
            "    static bool less(const Line &x, const Line &y, const i64 &p)",
            "    {",
            "        return x.at(p) < y.at(p);",
            "    }",
            "    static double intersect(const Line &x, const Line &y)",
            "    {",
            "        return double(y.b - x.b) / double(y.k - x.k);",
            "    }",
            "",
            "    void init(int x1, int x2)",
            "    {",
            "        if (x1 > x2)",
            "            minx = x2, maxx = x1;",
            "        else",
            "            minx = x1, maxx = x2;",
            "        build(1, minx, maxx);",
            "    }",
            "    void insert(const Line &g, int x1, int x2) { _insert(g, x1, x2, 1, minx, maxx); }",
            "    i64 ask(int x) const { return _getmax(x, 1, minx, maxx); }",
            "",
            "private:",
            "    struct Node",
            "    {",
            "        bool vis, has_line;",
            "        Line f;",
            "        Node() {}",
            "        Node(bool _v, bool _h) : vis(_v), has_line(_h), f() {}",
            "    };",
            "    Node tr[LEN << 2];",
            "    int minx, maxx;",
            "    void build(int p, int l, int r)",
            "    {",
            "        tr[p] = Node(false, false);",
            "        if (l == r)",
            "            return;",
            "        int mid = (l + r) >> 1;",
            "        build(p << 1, l, mid);",
            "        build(p << 1 | 1, mid + 1, r);",
            "    }",
            "    void _update(Line g, int p, int l, int r)",
            "    {",
            "        tr[p].vis = true;",
            "        if (!tr[p].has_line)",
            "        {",
            "            tr[p].has_line = true;",
            "            tr[p].f = g;",
            "            return;",
            "        }",
            "        Line &f = tr[p].f;",
            "        int mid = (l + r) >> 1;",
            "        if (less(f, g, mid))",
            "            std::swap(f, g);",
            "        if (l == r)",
            "            return;",
            "        if (less(f, g, l))",
            "            _update(g, p << 1, l, mid);",
            "        if (less(f, g, r))",
            "            _update(g, p << 1 | 1, mid + 1, r);",
            "    }",
            "    void _insert(const Line &g, int x, int y, int p, int l, int r)",
            "    {",
            "        tr[p].vis = true;",
            "        if (x <= l && r <= y)",
            "            return _update(g, p, l, r);",
            "        int mid = (l + r) >> 1;",
            "        if (x <= mid)",
            "            _insert(g, x, y, p << 1, l, mid);",
            "        if (y > mid)",
            "            _insert(g, x, y, p << 1 | 1, mid + 1, r);",
            "    }",
            "    i64 _getmax(int x, int p, int l, int r) const",
            "    {",
            "        if (!tr[p].vis)",
            "            return -inf;",
            "        i64 ans = tr[p].has_line ? tr[p].f.at(x) : -inf;",
            "        if (l == r)",
            "            return ans;",
            "        int mid = (l + r) >> 1;",
            "        if (x <= mid)",
            "            return std::max(ans, _getmax(x, p << 1, l, mid));",
            "        else",
            "            return std::max(ans, _getmax(x, p << 1 | 1, mid + 1, r));",
            "        return ans;",
            "    }",
            "};"
        ],
        "description": "Snippet from ./数据结构/李超线段树.cpp"
    },
    "FHQ Treap (Reverse)": {
        "prefix": "FHQ Treap (Reverse)",
        "body": [
            "#include <bits/stdc++.h>",
            "/*",
            " * FHQ Treap模板(区间反转版)",
            " * 功能：区间反转",
            " * 基准模板：洛谷P3391 【模板】文艺平衡树",
            " * Link: https://www.luogu.com.cn/problem/P3391",
            " */",
            "template <class T>",
            "class Tree",
            "{",
            "",
            "private:",
            "    struct Node",
            "    {",
            "        /* data */",
            "        size_t son[2];",
            "        int32_t rand;",
            "        size_t size;",
            "        T val;",
            "        bool tag;",
            "    };",
            "    int32_t seed;",
            "    size_t root, cnt;",
            "    std::vector<Node> tr;",
            "    int32_t rand()",
            "    {",
            "        return seed = ((int64_t)(seed) * 238973) % 2147483647;",
            "    }",
            "    int32_t add(T val)",
            "    {",
            "        tr.push_back(Node{{0, 0}, rand(), 1, val, 0});",
            "        return tr.size() - 1;",
            "    }",
            "    void spread(int32_t now)",
            "    {",
            "        if (!tr[now].tag)",
            "            return;",
            "        std::swap(tr[now].son[0], tr[now].son[1]);",
            "        tr[tr[now].son[0]].tag ^= 1;",
            "        tr[tr[now].son[1]].tag ^= 1;",
            "        tr[now].tag = 0;",
            "    }",
            "    void updata(size_t now)",
            "    {",
            "        tr[now].size = tr[tr[now].son[0]].size + tr[tr[now].son[1]].size + 1;",
            "    }",
            "    void split(size_t now, size_t &a, size_t &b, size_t val)",
            "    {",
            "        if (!now)",
            "        {",
            "            a = b = 0;",
            "            return;",
            "        }",
            "        spread(now);",
            "        if (tr[tr[now].son[0]].size + 1 <= val)",
            "        {",
            "            a = now;",
            "            split(tr[now].son[1], tr[now].son[1], b, val - tr[tr[now].son[0]].size - 1);",
            "        }",
            "        else",
            "        {",
            "            b = now;",
            "            split(tr[now].son[0], a, tr[now].son[0], val);",
            "        }",
            "        updata(now);",
            "    }",
            "    int32_t merge(size_t a, size_t b)",
            "    {",
            "        if (!a || !b)",
            "        {",
            "            return a | b;",
            "        }",
            "        if (tr[a].rand < tr[b].rand)",
            "        {",
            "            spread(a);",
            "            tr[a].son[1] = merge(tr[a].son[1], b);",
            "            updata(a);",
            "            return a;",
            "        }",
            "        else",
            "        {",
            "            spread(b);",
            "            tr[b].son[0] = merge(a, tr[b].son[0]);",
            "            updata(b);",
            "            return b;",
            "        }",
            "    }",
            "    void printF(size_t now)",
            "    {",
            "        spread(now);",
            "        if (tr[now].son[0])",
            "            printF(tr[now].son[0]);",
            "        std::cout << tr[now].val << ' ';",
            "        if (tr[now].son[1])",
            "            printF(tr[now].son[1]);",
            "    }",
            "",
            "public:",
            "    Tree(int32_t initSeed = 19260917)",
            "    {",
            "        tr.push_back(Node{{0, 0},",
            "                          rand(),",
            "                          0,",
            "                          std::numeric_limits<T>::min(),",
            "                          0});",
            "    };",
            "    void get(std::vector<T> a)",
            "    {",
            "        for (auto x : a)",
            "            root = merge(root, add(x));",
            "    }",
            "    void reverse(size_t l, size_t r)",
            "    {",
            "        size_t left, right, pos;",
            "        split(root, left, right, r);",
            "        split(left, left, pos, l - 1);",
            "        tr[pos].tag ^= 1;",
            "        root = merge(merge(left, pos), right);",
            "    }",
            "",
            "    void print()",
            "    {",
            "        printF(root);",
            "    }",
            "};",
            "Tree<int32_t> a;",
            "int32_t main()",
            "{",
            "    int32_t n, m;",
            "    std::cin >> n >> m;",
            "    std::vector<int32_t> num(n);",
            "    for (size_t i = 0; i < n; i++)",
            "        num[i] = i + 1;",
            "    a.get(num);",
            "    for (size_t i = 1, l, r; i <= m; i++)",
            "    {",
            "        std::cin >> l >> r;",
            "        a.reverse(l, r);",
            "    }",
            "    a.print();",
            "}"
        ],
        "description": "Snippet from ./数据结构/查找树/FHQ Treap (Reverse).cpp"
    },
    "01Treap(Trieset)": {
        "prefix": "01Treap(Trieset)",
        "body": [
            "",
            "#include <bits/stdc++.h>",
            "class Trieset",
            "{",
            "private:",
            "    std::vector<std::array<int, 2>> tr;",
            "    std::vector<int> siz;",
            "",
            "public:",
            "    Trieset()",
            "    {",
            "        tr.resize(2);",
            "        siz.resize(2);",
            "        tr[0] = {};",
            "        tr[1] = {};",
            "    }",
            "    void clear()",
            "    {",
            "        (*this) = Trieset();",
            "    }",
            "    void insert(int x, int cnt = 1)",
            "    {",
            "        int now = 1;",
            "        for (int i = 31, t; i >= 0; i--)",
            "        {",
            "            t = (x >> i) & 1;",
            "            if (!tr[now][t])",
            "            {",
            "                tr.push_back({});",
            "                siz.push_back(0);",
            "                tr[now][t] = tr.size() - 1;",
            "            }",
            "            siz[now = tr[now][t]] += cnt;",
            "        }",
            "    }",
            "    bool erase(int x, int cnt = 1)",
            "    {",
            "        int now = 1;",
            "        for (int i = 31, t; i >= 0; i--)",
            "        {",
            "            t = (x >> i) & 1;",
            "            if (!tr[now][t])",
            "                return 0;",
            "            siz[now = tr[now][t]] -= cnt;",
            "            if (siz[now] < 0)",
            "                siz[now] = 0;",
            "        }",
            "        return 1;",
            "    }",
            "    int find_by_rank(int rank)",
            "    {",
            "        int ans = 0, now = 1;",
            "        for (int i = 31; i >= 0; i--)",
            "        {",
            "            if (siz[tr[now][0]] < rank)",
            "            {",
            "                rank -= siz[tr[now][0]];",
            "                ans |= 1 << i;",
            "                now = tr[now][1];",
            "            }",
            "            else",
            "            {",
            "                now = tr[now][0];",
            "            }",
            "        }",
            "        return ans;",
            "    }",
            "    int find_rank(int val)",
            "    {",
            "        int rank = 0, now = 1;",
            "        for (int i = 31; i >= 0; i--)",
            "        {",
            "            int t = (val >> i) & 1;",
            "            rank += t * (siz[tr[now][0]]);",
            "            now = tr[now][t];",
            "        }",
            "        return rank + 1;",
            "    }",
            "    int prev(int val)",
            "    {",
            "        return find_by_rank(find_rank(val) - 1);",
            "    }",
            "    int next(int val)",
            "    {",
            "        return find_by_rank(find_rank(val + 1));",
            "    }",
            "} a;"
        ],
        "description": "Snippet from ./数据结构/查找树/01Treap(Trieset).cpp"
    },
    "矩阵": {
        "prefix": "矩阵",
        "body": [
            "/*",
            " * 矩阵类",
            " * 实现了矩阵加法、减法、乘法以及取模",
            " */",
            "template <class T>",
            "class Matrix",
            "{",
            "private:",
            "    int32_t R, C;",
            "    std::vector<std::vector<T>> a;",
            "",
            "public:",
            "    /*",
            "     * 需要在初始化时传入其行数Rt与列数Ct",
            "     * 可选参数为矩阵初始初始值init_val",
            "     */",
            "    Matrix(const int Rt, const int Ct, T init_val = 0)",
            "    {",
            "        a = std::vector<std::vector<T>>(Rt, std::vector<T>(Ct, init_val));",
            "        R = Rt;",
            "        C = Ct;",
            "    }",
            "    Matrix(std::initializer_list<std::initializer_list<T>> init)",
            "    {",
            "        R = init.size();",
            "        if (R == 0) {",
            "            C = 0;",
            "            a = {};",
            "            return;",
            "        }",
            "        C = init.begin()->size();",
            "        for (const auto& row : init) {",
            "            if (row.size() != C) {",
            "                throw std::invalid_argument(\"All rows must have the same number of columns\");",
            "            }",
            "        }",
            "        a.reserve(R);",
            "        for (const auto& row : init) {",
            "            a.push_back(std::vector<T>(row));",
            "        }",
            "    }",
            "\tvoid init(std::initializer_list<std::initializer_list<T>> a)",
            "\t{",
            "\t\t(*this) = Matrix<T>(a);",
            "\t}",
            "    Matrix<T> operator*(const Matrix<T> b)",
            "    {",
            "        try",
            "        {",
            "            if (C != b.R)",
            "                throw \"SIZE DIFF\";",
            "        }",
            "        catch (std::string code)",
            "        {",
            "            std::cerr << \"MATRIX ERROR @ OPERATOR * : \" + code << std::endl;",
            "            exit(0);",
            "        }",
            "        Matrix<T> c(R, b.C, 0);",
            "        for (int i = 0; i < R; i++)",
            "            for (int j = 0; j < b.C; j++)",
            "                for (int k = 0; k < C; k++)",
            "\t\t\t\t\tc.a[i][j] = (c.a[i][j] + a[i][k] * b.a[k][j]);",
            "        return c;",
            "    }",
            "    Matrix<T> operator+(const Matrix<T> b)",
            "    {",
            "        try",
            "        {",
            "            if (R != b.R || C != b.C)",
            "                throw \"SIZE DIFF\";",
            "        }",
            "        catch (std::string code)",
            "        {",
            "            std::cerr << \"MATRIX ERROR @ OPERATOR + : \" + code << std::endl;",
            "            exit(0);",
            "        }",
            "        Matrix<T> c(R, C, 0);",
            "        for (int i = 0; i < R; i++)",
            "            for (int j = 0; j < C; j++)",
            "                c.a[i][j] = (a[i][j] + b.a[i][j]);",
            "",
            "        return c;",
            "    }",
            "    Matrix<T> operator*(const T val)",
            "    {",
            "        Matrix<T> c(a);",
            "        for (int i = 0; i < R; i++)",
            "            for (int j = 0; j < C; j++)",
            "                c.a[i][j] = (c.a[i][j] * val);",
            "        return c;",
            "    }",
            "\tMatrix& operator+= (const Matrix<T> &b) { return a = a + b;}",
            "\tMatrix& operator-= (const Matrix<T> &b) { return a = a - b;}",
            "\tMatrix& operator*= (const Matrix<T> &b) { return a = a * b;}",
            "    T sum()",
            "    {",
            "        T ans = 0;",
            "        for (auto line : a)",
            "            for (auto x : line)",
            "                ans = (ans + x);",
            "        return ans;",
            "    }",
            "\tauto getVec()",
            "\t{",
            "\t\treturn a;",
            "\t}",
            "\tMatrix transpos() ",
            "\t{",
            "\t\tMatrix<T> b(C, R);",
            "\t\tfor (int i = 0; i < R; i++)",
            "\t\t\tfor (int j = 0; j < C; j++)",
            "\t\t\t\tb.a[j][i] = a[i][j];",
            "\t\treturn b;",
            "\t}",
            "};"
        ],
        "description": "Snippet from ./数学/矩阵.cpp"
    },
    "FFT": {
        "prefix": "FFT",
        "body": [
            "namespace FFT",
            "{",
            "    const double PI = std::acos(-1);",
            "",
            "    class Complex",
            "    {",
            "    public:",
            "        Complex(double _real = 0, double _virtual = 0);",
            "        double getReal() const;",
            "        double getVirtual() const;",
            "        Complex operator+(const Complex &b) const;",
            "        Complex operator-(const Complex &b) const;",
            "        Complex operator*(const Complex &b) const;",
            "",
            "    private:",
            "        double x, y;",
            "    };",
            "    Complex::Complex(double _real, double _virtual) : x(_real), y(_virtual) {}",
            "    double Complex::getReal() const { return this->x; }",
            "    double Complex::getVirtual() const { return this->y; }",
            "    Complex Complex::operator+(const Complex &b) const",
            "    {",
            "        return Complex(this->x + b.x, this->y + b.y);",
            "    }",
            "    Complex Complex::operator-(const Complex &b) const",
            "    {",
            "        return Complex(this->x - b.x, this->y - b.y);",
            "    }",
            "    Complex Complex::operator*(const Complex &b) const",
            "    {",
            "        return Complex(this->x * b.x - this->y * b.y, this->x * b.y + this->y * b.x);",
            "    }",
            "",
            "    /* recursive FFT",
            "    void FFT(std::vector<Complex>& A, int flag = 1){",
            "        int n = A.size();",
            "        if(n == 1) return;",
            "        std::vector<Complex> A1(n >> 1), A2(n >> 1);",
            "        for(int i = 0; i < (n >> 1); ++i)",
            "            A1[i] = A[i << 1],",
            "            A2[i] = A[i << 1 | 1];",
            "        FFT(A1, flag); FFT(A2, flag);",
            "        Complex w1(std::cos(2.0 * PI / n), std::sin(2.0 * PI / n) * flag), wk(1, 0);",
            "        for(int k = 0; k < (n >> 1); wk = wk * w1, ++k)",
            "            A[k] = A1[k] + A2[k] * wk,",
            "            A[k + (n >> 1)] = A1[k] - A2[k] * wk;",
            "    }",
            "    */",
            "",
            "    // make reversed binary representation array",
            "    std::vector<int> makerev(const int &len)",
            "    {",
            "        std::vector<int> ans;",
            "        ans.emplace_back(0);",
            "        ans.emplace_back(len >> 1);",
            "        int l = 0;",
            "        while ((1 << l) < len)",
            "            l++;",
            "        for (int i = 2; i < len; ++i)",
            "            ans.emplace_back(ans[i >> 1] >> 1 | (i & 1) << (l - 1));",
            "        /*",
            "            ans[i >> 1] is the reversed representation of i >> 1",
            "            (i >> 1) << 1 = i, so in reversed representation we need ans[i >> 1] >> 1",
            "            if i & 1 == 1, then the MSB of reversed representation should be 1",
            "            that is (i & 1) << (l - 1)",
            "        */",
            "        return ans;",
            "    }",
            "",
            "    // iterative FFT",
            "    void FFT(std::vector<Complex> &A, const int &flag = 1)",
            "    {",
            "        static std::vector<int> rev;",
            "        int n = A.size();",
            "        if (int(rev.size()) != n)",
            "            rev.clear(),",
            "                rev = makerev(n);",
            "        for (int i = 0; i < n; ++i)",
            "            if (rev[i] > i)",
            "                std::swap(A[i], A[rev[i]]);",
            "        for (int len = 2, m = 1; len <= n; m = len, len <<= 1)",
            "        {",
            "            Complex w1(std::cos(2.0 * PI / len), std::sin(2.0 * PI / len) * flag), wk;",
            "            for (int l = 0, r = len; r <= n; l += len, r += len)",
            "            {",
            "                wk = Complex(1, 0);",
            "                for (int k = l; k < l + m; wk = wk * w1, ++k)",
            "                {",
            "                    Complex x = A[k] + A[k + m] * wk,",
            "                            y = A[k] - A[k + m] * wk;",
            "                    A[k] = x;",
            "                    A[k + m] = y;",
            "                }",
            "            }",
            "        }",
            "    }",
            "}"
        ],
        "description": "Snippet from ./数学/FFT.cpp"
    },
    "Modint": {
        "prefix": "Modint",
        "body": [
            "template <const unsigned MOD>",
            "class Modint",
            "{",
            "public:",
            "\tModint() = default;",
            "\tModint(unsigned int x) : val(x) {}",
            "\tunsigned int gnum() { return val; }",
            "\tfriend istream &operator>>(istream &in, Modint &a) { return in >> a.val; }",
            "\tfriend ostream &operator<<(ostream &out, Modint a) { return out << a.val; }",
            "\tfriend Modint operator+(const Modint &a, const Modint &b) { return (a.val + b.val) % MOD; }",
            "\tfriend Modint operator-(const Modint &a, const Modint &b) { return (a.val + MOD - b.val) % MOD; }",
            "\tfriend Modint operator*(const Modint &a, const Modint &b) { return (1ULL * a.val * b.val) % MOD; }",
            "\tfriend Modint operator/(const Modint &a, const Modint &b) { return a * __ksm(b.val); }",
            "\tfriend Modint &operator*=(const Modint &a, const Modint &b) { return a = a * b; }",
            "\tfriend Modint &operator+=(const Modint &a, const Modint &b) { return a = a + b; }",
            "\tfriend Modint &operator-=(const Modint &a, const Modint &b) { return a = a - b; }",
            "\tfriend Modint &operator/=(const Modint &a, const Modint &b) { return a = a / b; }",
            "\tfriend Modint &operator++(Modint &a) { return a += 1; }",
            "\tfriend Modint operator++(Modint &a, int)",
            "\t{",
            "\t\tModint x = a;",
            "\t\ta += 1;",
            "\t\treturn x;",
            "\t}",
            "\tfriend Modint &operator--(Modint &a) { return a -= 1; }",
            "\tfriend Modint operator--(Modint &a, int)",
            "\t{",
            "\t\tModint x = a;",
            "\t\ta -= 1;",
            "\t\treturn x;",
            "\t}",
            "\tfriend bool operator==(Modint a, Modint b) { return a.x == b.x; }",
            "\tfriend bool operator!=(Modint a, Modint b) { return !(a == b); }",
            "",
            "private:",
            "\tint val;",
            "\tModint __ksm(const Modint &base, long long k)",
            "\t{",
            "\t\tModint ans = 1;",
            "\t\twhile (k)",
            "\t\t{",
            "\t\t\tif (k & 1)",
            "\t\t\t\tans *= base;",
            "\t\t\tbase *= base;",
            "\t\t\tk /= 2;",
            "\t\t}",
            "\t\treturn ans;",
            "\t}",
            "};"
        ],
        "description": "Snippet from ./数学/Modint.cpp"
    },
    "计算几何": {
        "prefix": "计算几何",
        "body": [
            "#include <bits/stdc++.h>",
            "typedef double design_float;",
            "const design_float PI = acos(-1);",
            "const design_float eps = 1e-7;",
            "struct Vector",
            "{",
            "    design_float x, y;",
            "    Vector(design_float x = 0, design_float y = 0)",
            "        : x(x), y(y)",
            "    {",
            "    }",
            "    bool operator==(const Vector &b) const { return fabs(x - b.x) <= eps && fabs(y - b.y) <= eps; }",
            "    Vector operator+(const Vector &b) const { return Vector(x + b.x, y + b.y); }",
            "    Vector operator-(const Vector &b) const { return Vector(x - b.x, y - b.y); }",
            "    Vector operator*(const design_float &b) const { return Vector(x * b, y * b); }",
            "    Vector operator/(const design_float &b) const { return Vector(x / b, y / b); }",
            "    design_float operator*(const Vector &b) const { return x * b.x + y * b.y; }",
            "    // 重定义^为叉乘",
            "    design_float operator^(const Vector &b) const { return x * b.y - y * b.x; }",
            "    design_float length() const { return sqrt(x * x + y * y); }",
            "    design_float angle() const { return atan2(y, x); }",
            "    Vector unit() const { return *this / length(); }",
            "    // 将向量旋转angle角度，angle为弧度制",
            "    Vector rotate(design_float angle) const",
            "    {",
            "        return Vector(x * cos(angle) - y * sin(angle), x * sin(angle) + y * cos(angle));",
            "    }",
            "};",
            "typedef Vector Point;",
            "struct Line",
            "{",
            "    Point a, b;",
            "    Vector vec() { return b - a; }",
            "    Line(Point a = Point(), Point b = Point())",
            "        : a(a), b(b)",
            "    {",
            "    }",
            "    // 判断点c在直线上",
            "    bool isPointOnLine(Point c) { return ((b - a) ^ (c - a)) == 0; }",
            "    // 判断点c在线段上",
            "    bool isPointOnSegment(Point c)",
            "    {",
            "        return fabs((b - a) ^ (c - a)) <= eps && (c - a) * (c - b) <= eps;",
            "    }",
            "    // 求点c到直线的距离",
            "    design_float distanceToLine(Point c)",
            "    {",
            "        return fabs(((b - a) ^ (c - a)) / (b - a).length());",
            "    }",
            "    // 求点c到线段的距离",
            "    design_float distanceToSegment(Point c)",
            "    {",
            "        if ((c - a) * (b - a) < 0)",
            "            return (c - a).length();",
            "        if ((c - b) * (a - b) < 0)",
            "            return (c - b).length();",
            "        return distanceToLine(c);",
            "    }",
            "    // 求点c到线段的最近点",
            "    Point nearestPointToSegment(Point c)",
            "    {",
            "        if ((c - a) * (b - a) < 0)",
            "            return a;",
            "        if ((c - b) * (a - b) < 0)",
            "            return b;",
            "        design_float r = (c - a) * (b - a) / (b - a).length();",
            "        return a + (b - a).unit() * r;",
            "    }",
            "};",
            "namespace Geometry",
            "{",
            "    Point rotate(Point p, Point base, design_float angle)",
            "    {",
            "        return (p - base).rotate(angle) + base;",
            "    }",
            "    Point intersection(Line l1, Line l2)",
            "    {",
            "        design_float s1 = (l2.b - l2.a) ^ (l1.a - l2.a);",
            "        design_float s2 = (l2.b - l2.a) ^ (l1.b - l2.a);",
            "        return (l1.a * s2 - l1.b * s1) / (s2 - s1);",
            "    }",
            "    // 输入一个点集，返回凸包",
            "    std::vector<Point> getHull(std::vector<Point> p)",
            "    {",
            "        std::vector<Point> h, l;",
            "        std::sort(p.begin(), p.end(), [&](auto a, auto b)",
            "                  {",
            "        if (a.x != b.x) {",
            "            return a.x < b.x;",
            "        } else {",
            "            return a.y < b.y;",
            "        } });",
            "        p.erase(std::unique(p.begin(), p.end()), p.end());",
            "        if (p.size() <= 1)",
            "        {",
            "            return p;",
            "        }",
            "",
            "        for (auto a : p)",
            "        {",
            "            while (h.size() > 1 && ((a - h.back()) ^ (a - h[h.size() - 2])) <= 0)",
            "                h.pop_back();",
            "            while (l.size() > 1 && ((a - l.back()) ^ (a - l[l.size() - 2])) >= 0)",
            "                l.pop_back();",
            "            l.push_back(a);",
            "            h.push_back(a);",
            "        }",
            "        l.pop_back();",
            "        std::reverse(h.begin(), h.end());",
            "        h.pop_back();",
            "        l.insert(l.end(), h.begin(), h.end());",
            "        return l;",
            "    }",
            "    // 计算凸包的边长",
            "    design_float getHullLength(std::vector<Point> hull)",
            "    {",
            "        design_float res = 0;",
            "        for (int i = 0; i < hull.size(); i++)",
            "            res += (hull[i] - hull[(i + 1) % hull.size()]).length();",
            "        return res;",
            "    }",
            "    // 计算凸包的面积",
            "    design_float getHullArea(std::vector<Point> hull)",
            "    {",
            "        design_float res = 0;",
            "        for (int i = 0; i < hull.size(); i++)",
            "            res += (hull[i] ^ hull[(i + 1) % hull.size()]);",
            "        return fabs(res) / 2;",
            "    }",
            "    bool pointOnLeft(Point p, Line l)",
            "    {",
            "        return ((l.b - l.a) ^ (p - l.a)) > eps;",
            "    }",
            "    // 求半平面交，给定若干条有向线段，算法将其排序后，以左边为半平面，返回交的凸包。",
            "    std::vector<Point> getHalfPlane(std::vector<Line> lines)",
            "    {",
            "        sort(lines.begin(), lines.end(), [](auto a, auto b)",
            "             {",
            "            design_float angle1 = a.vec().angle(), angle2 = b.vec().angle();",
            "            if (fabs(angle1 - angle2) <= eps)",
            "                return pointOnLeft(a.a, b);",
            "            else",
            "                return angle1 < angle2; });",
            "        std::vector<Line> res;",
            "        for (auto x : lines)",
            "        {",
            "            if (!res.empty() && fabs(x.vec().angle() - res.back().vec().angle()) <= eps)",
            "                continue;",
            "            res.push_back(x);",
            "        }",
            "        lines.swap(res);",
            "        int len = lines.size();",
            "        int l = 1, r = 0;",
            "        std::vector<int> q(len * 2);",
            "        std::vector<Point> p(len * 2);",
            "        for (int i = 0; i < len; i++)",
            "        {",
            "            while (l < r && !pointOnLeft(p[r], lines[i]))",
            "                r--;",
            "            while (l < r && !pointOnLeft(p[l + 1], lines[i]))",
            "                l++;",
            "            q[++r] = i;",
            "            if (l < r && fabs((lines[q[r]].vec() ^ lines[q[r - 1]].vec())) <= eps)",
            "                if (lines[q[r]].vec() * lines[q[r - 1]].vec() < -eps)",
            "                    return std::vector<Point>();",
            "            if (l < r)",
            "                p[r] = intersection(lines[q[r]], lines[q[r - 1]]);",
            "        }",
            "        while (l < r && !pointOnLeft(p[r], lines[q[l]]))",
            "            r--;",
            "        if (r - l <= 1)",
            "            return std::vector<Point>();",
            "        p[l] = intersection(lines[q[r]], lines[q[l]]);",
            "        std::vector<Point> ans;",
            "        while (l <= r)",
            "        {",
            "            ans.push_back(p[l]);",
            "            l++;",
            "        }",
            "        return ans;",
            "    }",
            "}"
        ],
        "description": "Snippet from ./数学/计算几何.cpp"
    },
    "NTT": {
        "prefix": "NTT",
        "body": [
            "namespace NTT",
            "{",
            "    typedef long long i64;",
            "",
            "    /// quick power",
            "    /// @brief",
            "    /// @tparam MOD",
            "    /// @param x",
            "    /// @param y",
            "    /// @return",
            "    template <i64 MOD>",
            "    i64 qpow(i64 x, i64 y)",
            "    {",
            "        i64 ans = 1;",
            "        while (y)",
            "        {",
            "            if (y & 1)",
            "                ans = ans * x % MOD;",
            "            x = x * x % MOD;",
            "            y >>= 1;",
            "        }",
            "        return ans;",
            "    }",
            "",
            "    // make reversed binary representation array",
            "    /// @brief",
            "    /// @param rev",
            "    /// @param len",
            "    void makerev(std::vector<int> &rev, const int &len)",
            "    {",
            "        rev.resize(len);",
            "        rev[0] = 0;",
            "        rev[1] = len >> 1;",
            "        int l = 0;",
            "        while ((1 << l) < len)",
            "            l++;",
            "        for (int i = 2; i < len; ++i)",
            "            rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (l - 1));",
            "        /*",
            "            rev[i >> 1] is the reversed representation of i >> 1",
            "            (i >> 1) << 1 = i, so in reversed representation we need rev[i >> 1] >> 1",
            "            if i & 1 == 1, then the MSB of reversed representation should be 1",
            "            that is (i & 1) << (l - 1)",
            "        */",
            "    }",
            "",
            "    // iterative NTT",
            "    /// @brief",
            "    /// @tparam MOD",
            "    /// @param A",
            "    /// @param flag",
            "    template <i64 MOD>",
            "    void NTT(std::vector<i64> &A, const int &flag = 1)",
            "    {",
            "        static std::vector<int> rev;",
            "        static const i64 prt = 3, invprt = qpow<MOD>(prt, MOD - 2);",
            "        int n = A.size();",
            "        if (int(rev.size()) != n)",
            "            makerev(rev, n);",
            "        for (int i = 0; i < n; ++i)",
            "            if (rev[i] > i)",
            "                std::swap(A[i], A[rev[i]]);",
            "        for (int len = 2, m = 1; len <= n; m = len, len <<= 1)",
            "        {",
            "            i64 w1 = qpow<MOD>(flag == 1 ? prt : invprt, (MOD - 1) / len), wk;",
            "            for (int l = 0, r = len, k; r <= n; l += len, r += len)",
            "            {",
            "                for (k = l, wk = 1; k < l + m; wk = wk * w1 % MOD, ++k)",
            "                {",
            "                    i64 x = A[k], y = A[k + m] * wk % MOD;",
            "                    A[k] = (x + y) % MOD;",
            "                    A[k + m] = (x - y + MOD) % MOD;",
            "                }",
            "            }",
            "        }",
            "    }",
            "}"
        ],
        "description": "Snippet from ./数学/NTT.cpp"
    },
    "线性基": {
        "prefix": "线性基",
        "body": [
            "struct Basis",
            "{",
            "#define BITSIZ 63",
            "    typedef unsigned long long ull;",
            "    std::array<ull, BITSIZ> arr;",
            "    int dim = 0;",
            "    Basis()",
            "    {",
            "        fill(arr.begin(), arr.end(), 0);",
            "        dim = 0;",
            "    }",
            "    void insert(ull x)",
            "    {",
            "        for (int i = BITSIZ - 1; i >= 0; i--)",
            "            if ((x >> i) & 1ULL)",
            "                if (arr[i])",
            "                    x ^= arr[i];",
            "                else",
            "                {",
            "                    arr[i] = x;",
            "                    dim++;",
            "                    break;",
            "                }",
            "    }",
            "    void join(Basis b)",
            "    {",
            "        for (int i = 0; i < BITSIZ; i++)",
            "            if (b.arr[i])",
            "                insert(b.arr[i]);",
            "    }",
            "    ull calcMaxNum(ull base = 0)",
            "    {",
            "        for (int i = BITSIZ - 1; i >= 0; i--)",
            "            if ((arr[i] ^ base) > base)",
            "                base ^= arr[i];",
            "        return base;",
            "    }",
            "    // 返回行最简矩阵",
            "    Basis getSimplestForm()",
            "    {",
            "        Basis tmp = *this;",
            "        for (int i = BITSIZ - 1; i >= 0; i--)",
            "        {",
            "            if (tmp.arr[i] == 0)",
            "                continue;",
            "            for (int j = i - 1; j >= 0; j--)",
            "                if ((tmp.arr[i] >> j) & 1ULL)",
            "                    if (tmp.arr[j])",
            "                        tmp.arr[i] ^= tmp.arr[j];",
            "        }",
            "        return tmp;",
            "    }",
            "    ull getDimention()",
            "    {",
            "        return dim;",
            "    }",
            "    // 返回第k小的异或和,  必须是行最简矩阵",
            "    ull calcKthNum(ull k)",
            "    {",
            "        if (k == 0)",
            "            return 0;",
            "        ull ans = 0;",
            "        for (int i = 0; k && i < BITSIZ; i++)",
            "            if (arr[i])",
            "            {",
            "                if (k & 1)",
            "                    ans ^= arr[i];",
            "                k >>= 1;",
            "            }",
            "        if (k)",
            "            return -1;",
            "        return ans;",
            "    }",
            "};"
        ],
        "description": "Snippet from ./数学/线性基.cpp"
    },
    "组合数学": {
        "prefix": "组合数学",
        "body": [
            "#include <bits/stdc++.h>",
            "",
            "namespace Binom",
            "{",
            "    const int32_t N = 2e5 + 10;",
            "    const int64_t mod = 1e9 + 7;",
            "    int64_t fac[N], facRev[N];",
            "    auto quickPow(int64_t base, int32_t k)",
            "    {",
            "        int64_t ans = 1LL;",
            "        while (k)",
            "        {",
            "            if (k & 1)",
            "                ans = (ans * base) % mod;",
            "            base = (base * base) % mod;",
            "            k >>= 1;",
            "        }",
            "        return ans;",
            "    }",
            "    void init()",
            "    {",
            "        fac[0] = facRev[0] = 1;",
            "        for (int64_t i = 1; i < N; i++)",
            "            fac[i] = fac[i - 1] * i % mod;",
            "        for (int64_t i = 1; i < N; i++)",
            "            facRev[i] = quickPow(fac[i], mod - 2);",
            "    }",
            "    int64_t C(int n, int m)",
            "    {",
            "        return fac[n] * facRev[m] % mod * facRev[n - m] % mod;",
            "    }",
            "}"
        ],
        "description": "Snippet from ./数学/组合数学.cpp"
    },
    "__gnu_pbds的使用": {
        "prefix": "__gnu_pbds的使用",
        "body": [
            "/*",
            "头文件&命名空间部分",
            "*/",
            "#include <bits/extc++.h>",
            "using namespace __gnu_pbds; // 慎用，有部分命名冲突",
            "",
            "/*",
            "平衡树部分",
            "*/",
            "typedef pair<int, int> pii;",
            "__gnu_pbds; //;//tree<pii, null_type, less<pii>, rb_tree_tag, tree_order_statistics_node_update> tr;",
            "",
            "/*",
            "成员函数",
            "*/",
            "tr.insert(x);\t\t // 向树中插入一个元素 x，返回 std;//;//pair<point_iterator, bool>。",
            "tr.erase(x);\t\t // 从树中删除一个元素/迭代器 x，返回一个 bool 表明是否删除成功。",
            "tr.order_of_key(x);\t // 返回 x 以 Cmp_Fn 比较的排名。",
            "tr.find_by_order(x); // 返回 Cmp_Fn 比较的排名所对应元素的迭代器。",
            "tr.lower_bound(x);\t // 以 Cmp_Fn 比较做 lower_bound，返回迭代器。",
            "tr.upper_bound(x);\t // 以 Cmp_Fn 比较做 upper_bound，返回迭代器。",
            "join(x);\t\t\t // 将 x 树并入当前树，前提是两棵树的类型一样，x 树被删除。",
            "tr.split(x, b);\t\t // 以 Cmp_Fn 比较，小于等于 x 的属于当前树，其余的属于 b 树。",
            "tr.empty();\t\t\t // 返回是否为空。",
            "tr.size();\t\t\t // 返回大小。",
            "",
            "/*",
            "堆部分",
            "*/",
            "",
            "__gnu_pbds; //;//priority_queue<pii, greater<pii>, pairing_heap_tag> q;",
            "/*",
            "成员函数",
            "*/",
            "push();\t\t\t\t\t\t\t   // 向堆中压入一个元素，返回该元素位置的迭代器。",
            "pop();\t\t\t\t\t\t\t   // 将堆顶元素弹出。",
            "top();\t\t\t\t\t\t\t   // 返回堆顶元素。",
            "size();\t\t\t\t\t\t\t   // 返回元素个数。",
            "empty();\t\t\t\t\t\t   // 返回是否非空。",
            "modify(point_iterator, const key); // 把迭代器位置的 key 修改为传入的 key，并对底层储存结构进行排序。",
            "erase(point_iterator);\t\t\t   // 把迭代器位置的键值从堆中擦除。",
            "join(__gnu_pbds;//;//priority_queue &other);// 把 other 合并到 *this 并把 other 清空。",
            "",
            "/*",
            "复杂度分析",
            "*/",
            "push();    // O(1)",
            "pop();     // 最坏O(nlogn)均摊O(1)",
            "modify();  // 最坏O(nlogn)均摊O(1)",
            "erase();   // 最坏O(nlogn)均摊O(1)",
            "join();    // O(1)",
            "",
            "/*",
            "哈希表部分",
            "*/",
            "__gnu_pbds::gp_hash_table<int,int> mp2;",
            "/*",
            "自定义Hash函数",
            "*/",
            "struct custom_hash //手写的 hash 函数",
            "{",
            "    static uint64_t splitmix64(uint64_t x)",
            "    {",
            "        x+=0x9e3779b97f4a7c15;",
            "        x=(x^(x>>30))*0xbf58476d1ce4e5b9;",
            "        x=(x^(x>>27))*0x94d049bb133111eb;",
            "        return x^(x>>31);",
            "\t}",
            "\tsize_t operator()(uint64_t x) const",
            "\t{",
            "\t\tstatic const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
            "\t\treturn splitmix64(x + FIXED_RANDOM);",
            "\t}",
            "};",
            "gp_hash_table<long long, int, custom_hash> safe_hash_table;",
            "",
            "/*",
            "成员函数：与unordered_map一致",
            "*/"
        ],
        "description": "Snippet from ./杂项/__gnu_pbds的使用.cpp"
    }
}